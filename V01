turtles-own
[
  HP-type
]

extensions
[matrix
  array]
;turtles-own [index-no]

globals
[
  sizze
  setup-time      ; A Var for displaying setup time in monitor window
  Mas-Time
  col-col
  Energyy
  temp-tek
  eeenergy
  Energy
  Energy-new
  Energy-old
  current-temp
  links-ok
  ecq-bet
  seq-len         ; A Var Length of the sequence
  input-str       ; A Var Contains Inout String
  HP-List         ; A List that contains sequences of H and P
  HP-List-reference
  ;HP-List-matrix  ; Matrix: HP-List, converted to matrix
  Last-place-x    ; A List that contains just two items
  Last-place-y
  Local-cp
  CP-List         ; A List that contains all "connection potentials" in this format: [ (1,x1,y1) (1,x2,y2) (1,x3,y3) , ... ]
  CP-List-matrix  ; Matrix: CP List converted to matrix
  Last-H          ; A List that contains [index,X,Y]
  last-H-1        ; one H before last H
  last-h-1-index
  Last-H-Matrix   ; Matrix: Last-H, converted to matrix
  P-counter       ; A Var for counting P between two H
  neighbour-clearence
                  ; An array composed of four items : [ North East South West ]  that explains if a nighbourhood is vacant or occupied
  P-PL-Index
  neighbour-array
  CP-DIst-Array   ; An array to keep distance between each CP and H-Center

  x-vac           ; two points to be tested in a proceedure to know if they are vacant or not
  y-vac           ;
  isVacant        ; answer of above proceedure to the candidate points
  HP-Typee         ; for testing if a point is H or P
  ;-----------------------------------
  ; Two Lists, Actually for list in list:
  turtle-spec     ; turtle-spec ) internal list : to keep specs of each turtle
  turtles-list    ; turtle-list ) Whole list : to keep lists of specs of all turtles
  x-gen
  y-gen
  after-first-h
  min-dist-index

  neighbour-array-backup
  not-valid-item

  x-min-dist
  y-min-dist
  ]

to setup
  ask patches [set pcolor green]
  let tt timer
  reset-timer
  clear-all
  set col-col 0
  set sizze 0
  ask patches [set pcolor white]
  set seq-len length input-seq
  ;output-print seq-len
  setup-Turtles
  set-seq-color
  turn-to-matrix
  ;set HP-List []
  set cp-list []
  set local-cp []
  set Last-H []
  set turtle-spec []
  set turtles-list []
  set neighbour-clearence []
  set after-first-h 0
  set setup-time timer
  ;print timer
  reset-ticks
end

to clear_all
  clear-all
  set temp-tek 0
  ifelse col-col = 0
  [
    ask patches [set pcolor white]
  ]
  [
    ask patches [set pcolor black]
  ]
end


;; This part :
;;          1- Creates turtles as circles
;;          2- Number of turtles are equal to number of input string

to setup-turtles
  set seq-len length input-seq
  Create-turtles seq-len
  ask turtles [set shape "circle"]

  let ss 0
  while [ ss < seq-len ]
  [
    ask turtle ss [setxy ( 2 * ss ) + 20 70]
    ask turtle ss [set heading 90]
    set ss ss + 1
    ]

  set ss 0
  let ss2 0
  while [ ss < seq-len - 1]
  [
    set ss2 ss + 1
    ask turtle ss ;; tell the first turtle...
    [ create-link-with turtle ss2 ]
    set ss ss + 1
    ]
end

to set-seq-color
  set seq-len length input-seq
  set input-str input-seq
  ;output-print length input-str
  let ss 0
  while [ ss < seq-len ]
  [
    ifelse item ss input-str = "H"
    [
      ask turtle ss
      [ set color RED
        set HP-Type 1
       ]
    ]

    [
      ask turtle ss
      [
        set color BLUE
        set HP-Type 2
       ]
      ]
      set ss ss + 1
    ]
end


to turn-to-matrix
    ; counter : counts to number of all turtles
  let counter 0
  let xx 0
  let yy 0
  set turtle-spec []
  set turtles-list []
  while [ counter < seq-len ]
  [
    ask turtle counter [set label counter]
    ;---
    ;retrieve "XCOR" and "YCOR" and "Type(Color)" of each turtle then put to a list
    ifelse [color] of turtle counter = RED
    [
      set xx 1
      set turtle-spec lput xx turtle-spec
      ]
    [
      set xx 0
      set turtle-spec lput xx turtle-spec
      ]

    set xx [xcor] of turtle counter
    set yy [ycor] of turtle counter
    set turtle-spec lput xx turtle-spec
    set turtle-spec lput yy turtle-spec

    ; Add the list of current turtle to the list of all turtles
    set turtles-list lput turtle-spec turtles-list
    set turtle-spec []
    set counter counter + 1
  ]
   set HP-List matrix:from-row-list turtles-list
   ;PRINT HP-List
   ;PRINT matrix:pretty-print-text HP-List
   ;PRINT matrix:dimensions HP-List
   let number 0
   set number matrix:get HP-List 1 1
   ;PRINT number
end



to test_FBC
  let tt timer
  reset-timer

  ;-----------------------------------
  ; Other lists:
  ; CP-List(or CP in my algorithm) works as list that contains
  ; all desirable places for H to move
  set CP-List []
  ;
  ; "Possible" is a list to prevent us from using again a conn-pot
  ; place which is not possible to be used
  let possible ( list )
  ;
  ; COORD is a list with two item, just used to create (X,Y) pair for above lists
  let coord (list)
  ;
  ; CPC is a list with just two item: [Xcpc,Ycpc]
  let cpc (list)
  ;
  ; CP-DIST is a list that contains the distance between each CP and CPC
  let CP-Dist (list)

  ;-----------------------------------
  ; Define an important pair variable
  ; called "Last location: (Last-xcor,Last-ycor)"
  let last-xcor 40
  let last-ycor 40
  let placement-done 0
  ;----------------------------------
  ; For finding first sequences of "H"s
  let counter 0
  let ss 0
  ;let continous-P 0
  set p-counter 0
  let previous-h-index 0
  let first-H 0
  let local-last-h []

  ; ifelse item counter input-str = "H"
  ; Here: we check for the first appearence of H , and then we add it to CP-List
  while [ first-H = 0 ]
  [
    let word1 item counter input-str
    ifelse word1 = "P"
    [
      ; If still not reached to First H:
      ;--------------------------------------------------------
      ; change the value of Y in HP-LIST
      matrix:set HP-List counter 2 40
      ; Get X coordination from HP-LIST
      set ss matrix:get HP-List counter 1
      ; Move turtle to (X,40)
      ask turtle counter [setxy ss 40]
      ; set counter counter + 1
      ; just move and do nothing, untill you get to the first H
      set p-counter p-counter + 1
      set counter counter + 1
    ]
    ; OK TILL HERE
    [
      ; After finding the first H, we should perform these tasks:
      ; 1- Move the related turtle to the location with Offset
      ; 2- modify the location in HP-list
      ; 3- Create (x,Y+2), (x,Y-2) (X+2,Y) CP locations and make a matrix based on it
      ; 4- Update: Last-H , Last-Place

      ;---------------------------------------------------------------------------
      ; Step 1
      ;---------------------------------------------------------------------------
      ; LAST_XCOR=(X of current amino)
      set last-xcor matrix:get HP-List counter 1
      ; LAST_YCOR=(40)
      set last-ycor 40
      ; Move turtle to (X,40)
      ask turtle counter [setxy last-xcor 40]

      ;---------------------------------------------------------------------------
      ; Step 2
      ;---------------------------------------------------------------------------
      ; Set 40 for Y, in HP_LIST
      matrix:set HP-List counter 2 40

      ;---------------------------------------------------------------------------
      ; Step 3
      ;---------------------------------------------------------------------------
      ; Create CP_LIST for CPs
      set local-cp []

      ;------------------
      ; Adding 1st Item which belongs to North
      ; Creating (1,x,y+2)
      ; (1,-,-)
      set ss 1
      set local-cp lput ss local-cp
      ; (1,x, )
      set local-cp lput last-xcor local-cp
      ; (1,x, Y+2)
      set ss last-ycor + 2
      set local-cp lput ss local-cp
      ; add to CP-list
      set cp-list lput local-cp cp-list
      ;------------------
      ; Adding 2nd Item which belongs to East
      ; Creating (1,x+2,y)
      set local-cp []
      ; (1,-,-)
      set ss 1
      set local-cp lput ss local-cp
      ; (1,x+2,-)
      set ss last-xcor + 2
      set local-cp lput ss local-cp
      ; (1,x,Y)
      set local-cp lput last-ycor local-cp
      ; add to CP-list
      set cp-list lput local-cp cp-list
      ;------------------
      ; Adding 3rd Item which belongs to South
      ; Creating (1,x,y-2)
      set local-cp []
      ; (1,-,-)
      set ss 1
      set local-cp lput ss local-cp
      ; (1,x, )
      set local-cp lput last-xcor local-cp
      ; (1,x, Y-2)
      set ss last-ycor - 2
      set local-cp lput ss local-cp
      ; add to CP-list
      set cp-list lput local-cp cp-list

      ; Turn CP-LIST to MATRIX keeping CPs
      set CP-List-matrix matrix:from-row-list cp-list
      ;
      ; End for loop
      set first-h 1
      ;-------------------------------------------------

      ; Make a backup of last coordinations
      set last-place-x last-xcor
      set last-place-y last-ycor

      ; make a matrix of (Index,X,Y) for last H
      set local-last-h []
      set local-last-h lput counter local-last-h
      set local-last-h lput last-xcor local-last-h
      set local-last-h lput last-ycor local-last-h
      set last-h lput local-last-h last-h
      ;set last-h lput local-last-h last-h
      set last-h-matrix matrix:from-row-list last-h

      set counter counter + 1
      set p-counter 0
      ]
  ]
  ; #OK1



  let H-Center-x 0
  let H-Center-y 0
  ;PRINT "After First H"
  ;print matrix:pretty-print-text HP-List

  ;------------------------------------------------------------------------------------------------------
  ;------------------------------------------------------------------------------------------------------
  ;------------------------------------------------------------------------------------------------------
  ;------------------------------------------------------------------------------------------------------
  ; OK TILL HERE

  ;                                      MAIN LOOP
  while [ counter < seq-len ]
  [;1
      ;------------------------------------------------------------------------------------------------------
      ; #OK1
      let word1 item counter input-str
      ifelse word1 = "P"
      ;ifelse item counter input-str = "P"
      [
        ;print "A P"
        set counter counter + 1
        set p-counter p-counter + 1
      ]
      ;------------------------------------------------------------------------------------------------------
      [ ;                                IF it's H
       ;PRINT "New H [ while counter < seq_len]"

       ;PRINT "Last_H_Matrix"
       ;PRINT last-h-matrix

       ;PRINT "Last-X,YCor"
       ;PRINT last-xcor
       ;PRINT last-ycor

       ;PRINT "Last-Place-x,y"
       ;PRINT last-place-x
       ;PRINT last-place-y
       ; ==================================================
       ; ==================================================
       ;  UPDATING H-CENTER
       ;
       ; 1- Update H_Center (its a (x,y) that shows the center point of all Hs)(it is calculated from HP_LIST)
       ; ; #OK2
        set ss 0
        let stk1 0
        let stk2 0
        let stk3 0
        let add-x 0
        let add-y 0
        let num 0
        set stk3 counter - 1
        while [ss < counter]
        ;       0     4
        [;3a
          ; Read type of amino from HP_LIST
          set stk1 matrix:get HP-List ss 0 ; reads first(0) item from row=ss of HP-List

          ; If it is H ...
          if stk1 = 1
          [;4b
            ; Read its X , add to ADD_X
            set stk2 matrix:get HP-List ss 1
            set add-x add-x + stk2
            ; Read its Y , add to ADD_Y
            set stk2 matrix:get HP-List ss 2
            set add-y add-y + stk2

            ; Increase denumrator
            set num num + 1
          ];4b
          set ss ss + 1
        ];3a

        set H-center-x add-x / num
        set H-center-y add-y / num


        ; ==================================================
        ; ==================================================
        ; UPDATING CP-LIST

        ; OK TILL HERE

        ; 1- First we check if P_COUNTER is EVEN or ODD
        ; 2- Based on the results, we will have 3 types of CP lists : P_COUNTER=Even , P_COUNTER=Odd , P_COUNTER=0

        ; 1- checking even/oddness
        let P-Counter-odd 1
        set stk1 P-Counter
        set stk1 stk1 / 2
        set stk1 int stk1
        set stk1 stk1 * 2
        set P-Counter-odd P-Counter - stk1  ; now we know its even or odd

        ; ==================================================
        ; ==================================================  P_COUNTER=Even
        ; #3
        ; If P_COUNTER is Even  or ZERO
        if P-Counter-odd = 0
        [
          if p-counter > 0
          [
             ;PRINT "P-Counter is Even"
            ; Start from first amino
            let i 0
            let k 0
            set cp-list[]
            while [ i < counter ]
            ;       0     4
            [
              set local-cp []
              ;set cp-list []  ; ?
              ;-----------------------
              ; Read type of amino from HP_LIST (by reading first Item of the row in matrix)
              set stk1 matrix:get HP-List i 0
              ; 0 - 1
              ; if it is H then
              if stk1 = 1
              [
                ; get its X and Y
                set X-gen matrix:get HP-List i 1
                set Y-gen matrix:get HP-List i 2

                ; Set the general array which is called "neighbour-array" to 1s, and check the availability of neighbours
                set neighbour-clearence []
                set stk1 1
                set neighbour-clearence lput stk1 neighbour-clearence
                set neighbour-clearence lput stk1 neighbour-clearence
                set neighbour-clearence lput stk1 neighbour-clearence
                set neighbour-clearence lput stk1 neighbour-clearence
                ;--------------------------------------
                ; Then turn that list to an array
                set neighbour-array array:from-list neighbour-clearence
                ;--------------------------------------
                ; Call the procedure to check neighbours availability
                check-neighbour
                ; Now we know which neighbourhood is occupied from j=0 to j=3 in [ x1 x2 x3 x4 ]
                ;-------------------
                ; now check each position to know if it is available

                ;print neighbour-array

                let j 0
                while [ j < 4 ]
                ;       0   4
                [
                  ;
                  set stk1 array:item neighbour-array j
                  if stk1 = 1
                  [
                    ; now, we define two new coordination pair to keep candidate point to be added to CP-List
                    let new-cp-x x-gen
                    let new-cp-y y-gen
                    ;
                    let dist-x 0
                    let dist-y 0
                    ;
                    if j = 0
                    [
                      set new-cp-y y-gen + 2
                    ]
                    if j = 1
                    [
                      set new-cp-x x-gen + 2
                    ]
                    if j = 2
                    [
                      set new-cp-y y-gen - 2
                    ]
                    if j = 3
                    [
                      set new-cp-x x-gen - 2
                    ]

                    ; Now check if this point's distance is less than
                    ; Here , add (new-cp-x,new-cp-y) to the cp-list
                    ifelse last-place-x > new-cp-x
                    [
                      set dist-x last-place-x - new-cp-x
                    ]
                    [
                      set dist-x new-cp-x - last-place-x
                    ]
                    ifelse last-place-y > new-cp-y
                    [
                      set dist-y last-place-y - new-cp-y
                    ]
                    [
                      set dist-y new-cp-y - last-place-y
                    ]
                    ;----------------------------------------------
;                    print "last-place-X"
;                    print last-place-x
;                    print "last-place-Y"
;                    print last-place-y
;
;                    print "new-cp-x"
;                    print new-cp-x
;                    print "new-cp-y"
;                    print new-cp-y

                    let cc dist-x + dist-y
                    let dd p-counter + p-counter

;                    print "CC:"
;                    print CC
;
;                    print "DD:"
;                    print dd
;
                    if cc <= dd
                    [
                      ;print "ADD ONE"
                      set local-cp []
                      set stk2 1
                      set local-cp lput stk2 local-cp
                      set local-cp lput new-cp-x local-cp
                      set local-cp lput new-cp-y local-cp
                      set cp-list lput local-cp cp-list
                    ]
                  ]
                  set j j + 1
                ]
              ]
              ; Loop variable Incrementor
              set i i + 1
            ]
            set CP-List-Matrix matrix:from-row-list CP-List
            ;Print "CP_LIST_MATRIX counter:EVEN"
            ;print CP-List-Matrix
          ]
        ]

        ; OK TILL HERE
        ; ====================================================================
        ; ==================================================================== P_COUNTER=Odd
        ; #4
        ; If P_COUNTER is Odd
        if P-Counter-odd = 1
        [
          ;print "P-Counter is ODD"
          ; Start from first amino
          let i 0
          let k 0
          set cp-list[]
          while [ i < counter ]
          ;       0      5
          [
            set local-cp []
            ;set cp-list []  ; ?
            ;-----------------------
            ; Read type of amino from HP_LIST (by reading first Item of the row in matrix)
            set stk1 matrix:get HP-List i 0

            ; if it is H then
            if stk1 = 1
            [
              ; get its X and Y
              set X-gen matrix:get HP-List i 1
              set Y-gen matrix:get HP-List i 2

              ; Set the general array which is called "neighbour-array" to 1s, and check the availability of neighbours
              set neighbour-clearence []
              set stk1 1
              set neighbour-clearence lput stk1 neighbour-clearence
              set neighbour-clearence lput stk1 neighbour-clearence
              set neighbour-clearence lput stk1 neighbour-clearence
              set neighbour-clearence lput stk1 neighbour-clearence
              ;--------------------------------------
              ; Then turn that list to an array
              set neighbour-array array:from-list neighbour-clearence
              ;--------------------------------------
              ; Call the procedure to check neighbours availability
              check-neighbour-odd
              ; Now we know which neighbourhood is occupied from j=0 to j=3 in [ x1 x2 x3 x4 ]
              ;-------------------
              ; now check each position to know if it is available
              let j 0
              while [ j < 4 ]
              ;       1   4
              [
                ;
                set stk1 array:item neighbour-array j
                if stk1 = 1
                [
                  ; now, we define two new coordination pair to keep candidate point to be added to CP-List
                  let new-cp-x x-gen
                  let new-cp-y y-gen
                  ;
                  let dist-x 0
                  let dist-y 0
                  ;
                  if j = 0
                  [
                    set new-cp-y y-gen + 2
                    set new-cp-x x-gen + 2
                  ]
                  if j = 1
                  [
                    set new-cp-x x-gen + 2
                    set new-cp-y y-gen - 2
                  ]
                  if j = 2
                  [
                    set new-cp-y y-gen - 2
                    set new-cp-x x-gen - 2
                  ]
                  if j = 3
                  [
                    set new-cp-x x-gen - 2
                    set new-cp-y y-gen + 2
                  ]
                  ; Now check if this point's distance is less than
                  ; Here , add (new-cp-x,new-cp-y) to the cp-list
                  ifelse last-place-x > new-cp-x
                  [
                    set dist-x last-place-x - new-cp-x
                  ]
                  [
                    set dist-x new-cp-x - last-place-x
                  ]
                  ifelse last-place-y > new-cp-y
                  [
                    set dist-y last-place-y - new-cp-y
                  ]
                  [
                    set dist-y new-cp-y - last-place-y
                  ]
                  ;----------------------------------------------
                  let cc dist-x + dist-y
                  let dd p-counter * 2
                  ;if cc <= dd
                  ;[
                    set local-cp []
                    set stk2 1
                    set local-cp lput stk2 local-cp
                    set local-cp lput new-cp-x local-cp
                    set local-cp lput new-cp-y local-cp
                    set cp-list lput local-cp cp-list
                  ;]
                ]
                set j j + 1
              ]
            ]
            ; Loop variable Incrementor
            set i i + 1
          ]
          ;set CP-List-Matrix matrix:from-row-list CP-List
          set CP-List-Matrix matrix:from-row-list CP-List
          ;Print "CP_LIST_MATRIX counter:ODD"
          ;print CP-List-Matrix


          ;=====================================================
          ;=====================================================
          ; CP-List CORRECTION

          let dim-list matrix:dimensions CP-List-Matrix
          ;set dim-list matrix:pretty-print-text HP-List
          let dim-array array:from-list dim-list
          let j array:item dim-array 0

          let Lasthx matrix:get LAST-H-MATRIX 0 1
          let Lasthy matrix:get LAST-H-MATRIX 0 2

          ;print "Last-H-X,Y"
          ;print lasthx
          ;print lasthy




          let cpx 0
          let cpy 0

          let diffx 0
          let diffy 0

          let summ 0

          let num-odd 1

          set i 0
          while [i < j]
          [
            set cpx matrix:get cp-list-matrix i 1
            set cpy matrix:get cp-list-matrix i 2

            ifelse lasthx > cpx
            [
              set diffx lasthx - cpx
            ]
            [
              set diffx cpx - lasthx
            ]

            ifelse lasthy > cpy
            [
              set diffy lasthy - cpy
            ]
            [
              set diffy cpy - lasthy
            ]


            set summ diffy  + diffx

            ;set summ summ / 2
            set summ summ / 2
            set summ int summ
            set summ summ - 1
            let bkup summ

            set bkup bkup / 2
            set bkup int bkup
            set bkup bkup * 2
            set num-odd summ - bkup

            ;-> Summ
            ; 4+2=6 , 6/2=3 , 3-1=2
            ; 4+4=8 , 8/2=4 , 4-1=3

            ; 2/2=1   ,1int=1   , 1*2=2 , 2-2=0=Num_odd -> Even
            ; 3/2=1.5 ,1.5int=1 , 1*2=2 , 3-2=1=num_odd -> Odd

            if num-odd = 0
            [
              matrix:set cp-list-matrix i 0 0
            ]
            set i i + 1
          ]
          ;print CP-List-Matrix
          ;=====================================================
          ;=====================================================

        ] ; End of (IF P_COUNTER IS ODD)
        ;3c
        ; end of #OK3

        ; ====================================================================================================
        ; ====================================================================================================
        ; ====================================================================================================
        ; #5
        ;  - If P_counter=0 then
        ;       - make a list of CP of last H (Not occupied)(1-)
        ;       - calculate distance between H_Center and each point
        ;       - Place Last H to that point

        if p-counter = 0
        [;3b

          ;#OK4

          ;PRINT "P-Counter=0"
          set stk1 0
          let number 0
          let cp-around []
          set local-cp []
          let x-pos 0
          let y-pos 0
          ;--------------------------------------
          ; Firstly, get coordination of Last H , and put it into (x-gen,y-gen)
          set x-gen matrix:get last-h-matrix 0 1
          set y-gen matrix:get last-h-matrix 0 2

          ;#OK5

          ;--------------------------------------
          ; Then Create a list of Four possible places around it
          ;--------------------------------------
          ; Here, we create a list called "neighbour-clearence", and set all of its items to one
          set stk1 1
          set neighbour-clearence []
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          ;--------------------------------------
          ; Then turn that list to an array
          set neighbour-array array:from-list neighbour-clearence
          ;--------------------------------------
          check-neighbour
          set neighbour-array-backup neighbour-array


          ; Now we know which neighbourhood is Vacant and H could be placed in it

          ; #OK6

          let xx 0
          let yy 0
          let min-dist 100
          let best-x 0
          let best-y 0
          let first-time 0
          ;-------------------
          ; Reading N
          set stk1 array:item neighbour-array 0
          if stk1 = 1
          [;4b
            set stk1 y-gen + 2
            set xx h-center-x - x-gen
            set xx xx ^ 2
            set yy h-center-y - stk1
            set yy yy ^ 2
            set stk1 yy + xx
            set stk1 sqrt stk1

            ifelse first-time = 0
            [
              set min-dist stk1
              set best-x x-gen
              set best-y y-gen + 2
              set first-time 1
              set not-valid-item 0
            ]

            [
              if stk1 < min-dist
              [
                set min-dist stk1
                set best-x x-gen
                set best-y y-gen + 2
                set not-valid-item 0
              ]
            ]

          ];4b

           ;-------------------
           ; Reading E
          set stk1 array:item neighbour-array 1
          if stk1 = 1
          [;4c
            set stk1 x-gen + 2
            set xx h-center-x - stk1
            set xx xx ^ 2
            set yy h-center-y - y-gen
            set yy yy ^ 2
            set stk1 yy + xx
            set stk1 sqrt stk1
            ifelse first-time = 0
            [
              set min-dist stk1
              set best-x x-gen + 2
              set best-y y-gen
              set first-time 1
              set not-valid-item 1
            ]
            [
              if stk1 < min-dist
              [
                set min-dist stk1
                set best-x x-gen + 2
                set best-y y-gen
                set not-valid-item 1
              ]
            ]
          ];4c

          ;-------------------
          ; Reading S

          set stk1 array:item neighbour-array 2
          if stk1 = 1
          [;4d
            set stk1 y-gen - 2
            set xx h-center-x - stk1
            set xx xx ^ 2
            set yy h-center-y - y-gen
            set yy yy ^ 2
            set stk1 yy + xx
            set stk1 sqrt stk1
            ifelse first-time = 0
            [
              set min-dist stk1
              set best-x x-gen
              set best-y y-gen - 2
              set first-time 1
              set not-valid-item 2
            ]
            [
              if stk1 < min-dist
              [
                set min-dist stk1
                set best-x x-gen
                set best-y y-gen - 2
                set not-valid-item 2
              ]
            ]
          ];4d

          ;-------------------
          ; Reading W
          set stk1 array:item neighbour-array 3
          if stk1 = 1
          [;4e
            set stk1 x-gen - 2
            set xx h-center-x - stk1
            set xx xx ^ 2
            set yy h-center-y - y-gen
            set yy yy ^ 2
            set stk1 yy + xx
            set stk1 sqrt stk1
            ifelse first-time = 0
            [
              set min-dist stk1
              set best-x x-gen - 2
              set best-y y-gen
              set first-time 1
              set not-valid-item 3
            ]
            [
              if stk1 < min-dist
              [
                set min-dist stk1
                set best-x x-gen - 2
                set best-y y-gen
                set not-valid-item 3
              ]
            ]
          ];4e

          ;==============================================================================
          ; ## check kon ke in noghte ke candide gozashtane H e jadid shode , aya hamsayegi khali dare ya na?

          ;#OK7

          ;--------------------------------------
          ; Now , we check again to be sure that the candidate point:(best-x , best-y) have
          ; at least one vacant position
          set x-gen best-x
          set y-gen best-y
          ;--------------------------------------
          ; Then Create a list of Four possible places around it
          ;--------------------------------------
          ; Here, we create a list called "neighbour-clearence", and set all of its items to one
          set stk1 1
          set neighbour-clearence []
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          ;--------------------------------------
          ; Then turn that list to an array
          set neighbour-array array:from-list neighbour-clearence
          ;--------------------------------------
          check-neighbour
          ; Now we know which neighbourhood is occupied

          let i 0
          let one-vacant 0
          while [ i < 4 ]
          [
            set stk1 array:item neighbour-array i
            if stk1 = 1
            [
              set one-vacant 1
            ]
            set i i + 1
          ]

          ;--------------------------------------
          ; Firstly, get coordination of Last H , and put it into (x-gen,y-gen)
          set x-gen matrix:get last-h-matrix 0 1
          set y-gen matrix:get last-h-matrix 0 2

          ;#OK8

          if one-vacant = 0
          [
            array:set neighbour-array-backup not-valid-item 0
            ;=================================================
            set xx 0
            set yy 0
            set min-dist 100
            set best-x 0
            set best-y 0
            set first-time 0
            ;-------------------
            ; Reading N
            set stk1 array:item neighbour-array-backup 0
            if stk1 = 1
            [;4b

              set stk1 y-gen + 2
              set xx h-center-x - x-gen
              set xx xx ^ 2
              set yy h-center-y - stk1
              set yy yy ^ 2
              set stk1 yy + xx
              set stk1 sqrt stk1

              ifelse first-time = 0
              [
                set min-dist stk1
                set best-x x-gen
                set best-y y-gen + 2
                set first-time 1
                set not-valid-item 0
              ]

              [
                if stk1 < min-dist
                [
                  set min-dist stk1
                  set best-x x-gen
                  set best-y y-gen + 2
                  set not-valid-item 0
                ]
              ]

            ];4b

             ;-------------------
             ; Reading E
            set stk1 array:item neighbour-array-backup 1
            if stk1 = 1
            [;4c
              set stk1 x-gen + 2
              set xx h-center-x - stk1
              set xx xx ^ 2
              set yy h-center-y - y-gen
              set yy yy ^ 2
              set stk1 yy + xx
              set stk1 sqrt stk1
              ifelse first-time = 0
              [
                set min-dist stk1
                set best-x x-gen + 2
                set best-y y-gen
                set first-time 1
                set not-valid-item 1
              ]
              [
                if stk1 < min-dist
                [
                  set min-dist stk1
                  set best-x x-gen + 2
                  set best-y y-gen
                  set not-valid-item 1
                ]
              ]
            ];4c

             ;-------------------
             ; Reading S

            set stk1 array:item neighbour-array-backup 2
            if stk1 = 1
            [;4d
              set stk1 y-gen - 2
              set xx h-center-x - stk1
              set xx xx ^ 2
              set yy h-center-y - y-gen
              set yy yy ^ 2
              set stk1 yy + xx
              set stk1 sqrt stk1
              ifelse first-time = 0
              [
                set min-dist stk1
                set best-x x-gen
                set best-y y-gen - 2
                set first-time 1
                set not-valid-item 2
              ]
              [
                if stk1 < min-dist
                [
                  set min-dist stk1
                  set best-x x-gen
                  set best-y y-gen - 2
                  set not-valid-item 2
                ]
              ]
            ];4d

             ;-------------------
             ; Reading W
            set stk1 array:item neighbour-array-backup 3
            if stk1 = 1
            [;4e
              set stk1 x-gen - 2
              set xx h-center-x - stk1
              set xx xx ^ 2
              set yy h-center-y - y-gen
              set yy yy ^ 2
              set stk1 yy + xx
              set stk1 sqrt stk1
              ifelse first-time = 0
              [
                set min-dist stk1
                set best-x x-gen - 2
                set best-y y-gen
                set first-time 1
                set not-valid-item 3
              ]
              [
                if stk1 < min-dist
                [
                  set min-dist stk1
                  set best-x x-gen - 2
                  set best-y y-gen
                  set not-valid-item 3
                ]
              ]
            ];4e
          ]

          ;============================================================================== ^
          ;#OK9
          ask turtle counter [ setxy best-x best-y ]  ;ok

          ;print "Look Section"
          set Last-H-1 matrix:get LAST-H-MATRIX 0 0

          ;#OK10
          ; ****   Modify its position in HP-LIST  ****
          matrix:set HP-List counter 1 best-x
          matrix:set HP-List counter 2 best-y   ;ok

          ;print matrix:pretty-print-text HP-List

          ; Set this coordination for last H
          set last-xcor best-x
          set last-ycor best-y    ;ok

          set last-place-x best-x
          set last-place-y best-y  ;ok

          ; Revise the coordination in Last-H-Matrix
          matrix:set Last-h-matrix 0 0 counter
          matrix:set Last-h-matrix 0 1 best-x
          matrix:set Last-h-matrix 0 2 best-y

          ;PRINT "in continuous P: last-h-1 , last-h-matrix"
          ;PRINT last-h-1
          ;PRINT last-h-matrix

          ;PRINT "zzzzz"
          ;PRINT matrix:pretty-PRINT-text HP-List
          ;PRINT matrix:pretty-print-text Last-h-matrix

          ;PRINT "CP_LIST_MATRIX counter: ZERO"
          ;PRINT CP-List-Matrix

          set counter counter + 1
          set p-counter 0
          ;PRINT "End of P-Counter=0"
        ];3b
        ;     Upda0ting CP-List is done
        ; ====================================================================================================
        ; ====================================================================================================
        ; ====================================================================================================
        ;                                              If P_Counter>0
        ;
        if p-counter > 0
        [;3c
          ;#OK11
          ;print "P-Counter > 0"
          set placement-done 0
          ;print "IN P-COUNTER > 0"

          ;---------------------------------------------------------------------------
          while [ placement-done = 0 ]
          [
            ;print "WHILE [ PLACEMENT-DONE = 0] "
            ; ==================================================
            ; ==================================================
            ;  UPDATING H-CENTER
            ;#OK12
            ; 1- Update H_Center (its a (x,y) that shows the center point of all Hs)(it is calculated from HP_LIST)
            set ss 0
            set stk1 0
            set stk2 0
            set stk3 0
            set add-x 0
            set add-y 0
            set num 0
            set stk3 counter - 1
            while [ss < counter]
            ;       0     5
            [;3a
              set stk1 matrix:get HP-List ss 0 ; reads first(0) item from row=ss of HP-List

              if stk1 = 1
              [;4b
                set stk2 matrix:get HP-List ss 1
                set add-x add-x + stk2

                set stk2 matrix:get HP-List ss 2
                set add-y add-y + stk2

                set num num + 1
              ];4b
              set ss ss + 1
            ];3a

            set H-center-x add-x / num
            set H-center-y add-y / num

            ;print "H-CENTER-X,Y"
            ;Print H-center-x
            ;Print H-center-y
            ; ==================================================
            ; ==================================================
            ; UPDATE CP-DIST
            ;#OK13
            ;  - Update CP_Dist
            ;    Here we calculate the distance between all CPs attained in previous sections with
            ;    H-Center
            set cp-dist []
            ; - First we should get CP-List-Matrix current dimention to find "J" which
            ;     is used to count all CPs
            ; - Now, we create a list which would be translated to an array called "CP-Dist-Array "
            let local-cp-dist []
            let dim-list matrix:dimensions Cp-List-Matrix
            let dim-array array:from-list dim-list
            let j array:item dim-array 0

            set x-min-dist 0
            set y-min-dist 0

            let min-dist 100

            ;let
            let ii 0
            ;let stk1 0
            while [ ii < j ]
            ;       0    3
            [
              set stk3 matrix:get CP-List-Matrix ii 0  ; Check availablity of that point
              set stk1 matrix:get CP-List-Matrix ii 1  ; X
              set stk2 matrix:get CP-List-Matrix ii 2  ; Y
              ifelse stk3 = 1
              [
                ifelse stk1 >= h-center-x
                [
                  set stk1 stk1 - h-center-x
                ]
                [
                  set stk1 h-center-x - stk1
                ]
                ifelse stk2 >= h-center-y
                [
                  set stk2 stk2 - h-center-y
                ]


                [
                  set stk2 h-center-y - stk2
                ]
                ; Here we calculate the distance between current CP and H-Center
                set stk1 stk1 * stk1
                set stk2 stk2 * stk2
                set stk3 stk1 + stk2
                set stk3 sqrt stk3

                ; Now we put it in cp-dist list
                set CP-Dist lput stk3 CP-Dist
              ]
              [
                set CP-Dist lput 100 CP-Dist
              ]
              set ii ii + 1
            ]
            ;===
            set CP-Dist-Array array:from-list cp-dist

            ;PRINT "CP-LIST-MATRIX"
            ;PRINT CP-LIST-MATRIX
            ;PRINT "+ CP-Dist-Array :"
            ;PRINT CP-Dist-Array
            ;set CP-Dist-Array array:from-list neighbour-array
            ;===

            ;print CP-Dist-Array
            let ar-len array:length CP-DIst-Array


            ; ==================================================
            ; ==================================================
            ; SELECT CLOSEST COORD
            ;#OK14
            set ii 0
            while [ ii < ar-len ]
            ;        0     3
            [
              set stk1 array:item CP-DIst-Array  ii
              ;
              if stk1 < min-dist
              ;    1      100
              [
                set stk3 matrix:get CP-List-Matrix ii 0  ; check the possiblity of using that point (from CP-LIST)
                if stk3 = 1
                [
                  ;  - Extract (x_min_dist,y_min_dist) of the minimum distance
                  set min-dist stk1
                  set x-min-dist matrix:get CP-List-Matrix ii 1  ; X of a CP with least distance (turtle moves to it)
                  set y-min-dist matrix:get CP-List-Matrix ii 2  ; Y of a CP with least distance (turtle moves to it)
                  set min-dist-index ii
;                  PRINT "Closest selected X,Y"
;                  print x-min-dist
;                  print y-min-dist
                ]
              ]
              set ii ii + 1
            ]




            ; ==================================================
            ; ==================================================
            ; CHECK THE NUMBER OF POSSIBLE LOCATIONS
            ; --- IF POSSIBLE-PLACES = 0
            ; ------- DISABLE POSITION OF LAST(PREVIOUS) H IN CP-LIST
            ; ------- UPDATE CP-LIST
            ; ------- UPDATE H-CENTER
             if min-dist = 100
            [
              ; it means its a bloody situation and previous H should move to a new position
              ;PRINT "BLOODY SITUATION!"
              ;#OK15
              ; checking if p-counter is even or odd
              set p-counter-odd 1
              set stk1 p-counter
              set stk1 stk1 / 2
              set stk1 int stk1
              set stk1 stk1 * 2
              set p-counter-odd p-counter - stk1

              let lasthx matrix:get LAST-H-MATRIX 0 1
              let lasthy matrix:get LAST-H-MATRIX 0 2

              set dim-list matrix:dimensions HP-List
              set dim-array array:from-list dim-list
              set j array:item dim-array 0

              if P-counter-odd = 0
              [
                ;PRINT "PCOUNTER IS EVEN"
                ;#OK16

                ;]]]]]]]]]]
                ;------------------------
                ;------------------------
                set cp-list []
                let occu-counter 0
                let occupied 0
                let xx lasthx + 4
                let yy lasthy - 2
                let READY 0
                let i 0
                while [ i < j ]
                ;
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx + 2
                set yy lasthy - 0
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]
                set xx lasthx + 6
                set yy lasthy - 0
                if occupied = 0
                [
                  set local-cp []
                  set stk2 1
                  set READY ready + 1
                  set local-cp lput stk2 local-cp
                  set local-cp lput xx local-cp
                  set local-cp lput yy local-cp
                  set cp-list lput local-cp cp-list
                ]
                ;------------------------
                ;------------------------
                set xx lasthx + 0
                set yy lasthy + 6
                set occupied 0
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx + 0
                set yy lasthy + 2
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx + 0
                set yy lasthy + 6
                if occupied = 0
                [
                  set local-cp []
                  set stk2 1
                  set local-cp lput stk2 local-cp
                  set READY ready + 1
                  set local-cp lput xx local-cp
                  set local-cp lput yy local-cp
                  set cp-list lput local-cp cp-list
                ]
                ;------------------------
                ;------------------------
                set xx lasthx - 6
                set yy lasthy - 0
                set occupied 0
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      set occu-counter occu-counter + 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx - 2
                set yy lasthy - 0
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx - 6
                set yy lasthy - 0
                if occupied = 0
                [
                  set local-cp []
                  set stk2 1
                  set READY ready + 1
                  set local-cp lput stk2 local-cp
                  set local-cp lput xx local-cp
                  set local-cp lput yy local-cp
                  set cp-list lput local-cp cp-list
                ]
                ;------------------------
                ;------------------------
                set xx lasthx - 0
                set yy lasthy - 6
                set occupied 0
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]


                set xx lasthx - 0
                set yy lasthy - 2
                set i 0
                while [ i < j ]
                ;       0    8
                [
                  let matrix-item matrix:get HP-List i 1
                  if xx = matrix-item
                  [
                    set matrix-item matrix:get HP-List i 2
                    if yy = matrix-item
                    [
                      set occupied 1
                      ;;PRINT "occupied = 1"
                    ]
                  ]
                  set i i + 1
                ]

                set xx lasthx - 0
                set yy lasthy - 6
                if occupied = 0
                [
                  set local-cp []
                  set stk2 1
                  set READY ready + 1
                  set local-cp lput stk2 local-cp
                  set local-cp lput xx local-cp
                  set local-cp lput yy local-cp
                  set cp-list lput local-cp cp-list
                ]
                ;------------------------
                ;------------------------
                ;PRINT "LAST-PLACE-X,Y"
                ;PRINT LAST-PLACE-X
                ;PRINT LAST-PLACE-Y


;                ifelse ready > 0
;                [
;                  ;PRINT "sth exist!"
;                ]
;                [
;                  ;PRINT "SHIT NOT  exist!"
;                ]
;
                if ready = 0
                [
                  set stk1 0
                  ;PRINT "~~~~~~~~~~~~~~~~~~"
                  ;PRINT "~~~~~~~~~~~~~~~~~~"
                  ;PRINT "LAST-PLACE-X,Y"
                  ;PRINT last-place-x
                  ;PRINT last-place-y
                  ;PRINT "Counter"
                  ;PRINT Counter
                  set stk1 counter - 1
                  ;PRINT "stk1"
                  ;PRINT stk1

                  set x-gen matrix:get hp-list stk1 1
                  set y-gen matrix:get hp-list stk1 2

                  ;PRINT "X,Y-Gen"
                  ;PRINT X-gen
                  ;PRINT Y-gen

                  set stk1 1
                  set neighbour-clearence []
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence

                  set neighbour-array array:from-list neighbour-clearence

                  check-neighbour

                  ;PRINT "neighbour-array"
                  ;PRINT neighbour-array
                  ; after making sure that this point is possible, we check if the candidate H goes there
                  ; it should have at least one vacant place

                  set i 0
                  Set xx x-gen
                  Set yy y-gen
                  while [ i < 3]
                  [
                    set stk1 array:item neighbour-array i
                    if stk1 = 1
                    [
                      if i = 0
                      [
                        set yy y-gen + 2
                      ]
                      if i = 1
                      [
                        set xx x-gen + 2
                      ]
                      if i = 2
                      [
                        set yy y-gen - 2
                      ]
                      if i = 3
                      [
                        set xx x-gen - 2
                      ]
                    ]
                    set x-gen xx
                    set y-gen yy

                    ;PRINT "X,Y-Gen 2"
                    ;PRINT X-gen
                    ;PRINT Y-gen

                    set stk1 1
                    set neighbour-clearence []
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-array array:from-list neighbour-clearence
                    check-neighbour

                    ;PRINT "neighbour-array"
                    ;PRINT neighbour-array

                    let vacancy 0
                    set j 0
                    while [ j < 3]
                    [
                      set stk1 array:item neighbour-array j
                      if stk1 = 1
                      [
                        set vacancy vacancy + 1
                      ]
                      set j j + 1
                    ]

                    if vacancy > 1
                    [
                      ;PRINT "VACANCY > 0"
                      if i = 0
                      [
                        set xx y-gen + 2
                      ]
                      if i = 1
                      [
                        set xx x-gen + 2
                      ]
                      if i = 2
                      [
                        set xx y-gen - 2
                      ]
                      if i = 3
                      [
                        set xx x-gen - 2
                      ]
                      set local-cp []
                      set stk2 1
                      set local-cp lput stk2 local-cp
                      set local-cp lput xx local-cp
                      set local-cp lput yy local-cp
                      set cp-list lput local-cp cp-list
                    ]

                    set i i + 1
                  ]
                ]

                ;PRINT matrix:pretty-print-text HP-list
                set CP-List-Matrix matrix:from-row-list CP-List
                ;PRINT "CP_LIST_MATRIX counter: REVISION"
                ;PRINT CP-List-Matrix
                ;]]]]]]]]]]
              ]
            ]




            ; ==================================================
            ; ==================================================
            ; --- IF POSSIBLE_PLACES > 0
            ; ------- CHECK IF "MIN-DIST","P-COUNTER" ARE MATCH
            if min-dist < 100
            [
              ;PRINT "IN MINDIST <100"


              ;PRINT "x-min-dist = "
              ;PRINT  x-min-dist
              ;PRINT "Y-min-dist = "
              ;PRINT  Y-min-dist

              ;PRINT "last-xcor = "
              ;PRINT  last-xcor
              ;PRINT "last-Ycor = "
              ;PRINT  last-Ycor
              ; a,b to keep X,Y difference between ()

              ;#OK17

              let a 0
              let b 0

              ;PRINT "+++"
              ;PRINT "In H placement process"

              ;PRINT "Current Amino"
              ;PRINT counter
              ;PRINT "Last-H-Matrix"
              ;PRINT Last-H-Matrix

              ifelse x-min-dist > last-xcor
              [
                set a x-min-dist - last-xcor
              ]
              [
                set a last-xcor - x-min-dist
              ]
              ;-----
              ifelse y-min-dist > last-ycor
              [
                set b y-min-dist - last-ycor
              ]
              [
                set b last-ycor - y-min-dist
              ]
              ;---------------------------------------------------------------------
              ;  - Now: P_Min=((a+b)/2)-1  : this means that the minimum number of P that we need to connect to this point is P_min

              let p-min 0
              set stk1 a + b
              set stk1 stk1 / 2
              set stk1 int stk1
              set p-min stk1 - 1

              ; Here we check if "p-min" is even or odd
              ; let supose "p-min" is odd
              let p-min-odd 1
              set stk1 p-min
              set stk1 stk1 / 2
              set stk1 int stk1
              set stk1 stk1 * 2
              set p-min-odd p-min - stk1

              ;---------------------------------------------------------------------
              ;  - Look at: P_counter
              ;  - Determine if : P_counter is even or odd. P_min is even or odd.
              ;#OK18
              set stk1 p-counter
              set stk1 stk1 / 2
              set stk1 int stk1

              ; Let supose "p-counter" is odd
              set p-counter-odd 1
              set stk1 p-counter
              set stk1 stk1 / 2
              set stk1 int stk1
              set stk1 stk1 * 2
              set p-counter-odd p-counter - stk1

              ; Now we define a new variable to assess if both "p-counter" and "p-min" are even or odd
              Let both-the-same 0

              ;Now assess...
              ifelse p-min-odd = 1
              [
                ifelse p-counter-odd = 1
                [
                  set both-the-same 1
                ]
                [
                  set both-the-same 0
                ]
              ]
              [
                ifelse p-counter-odd = 0
                [
                  set both-the-same 1
                ]
                [
                  set both-the-same 0
                ]
              ]
;              print "both-the-same  = "
;              print  both-the-same


              ;======================================================================
              ; -----------IF ARE-MATCH=1
              ; --------------- MOVE CURRENT H TO THIS POINT
              ; --------------- PLACE ALL Ps BETWEEN TWO LAST H
              ; --------------- COUNTER++

              ifelse both-the-same = 1
              [
                ; They are the same

                ;PRINT "in are-match Loop"
                ; baraye inke age beine noghte candid , va last-h ye aminoe dige bood , noghte candid ro disable kone
                ;#OK19
                let boroberim 1

                ;PRINT "p-counter , p-min"
                ;PRINT p-counter
                ;PRINT p-min
                ;#OK20
                ifelse p-counter >= p-min
                [
                  ;#OK21
                  ;PRINT "in p-counter >= p-min , next step H-Placement"
                  ;==============================================================
                  ;==============================================================
                  ; inja shart mizarim ke age beine noghte morede nazare ma baraye gharar dadne H e jadid yani (x-min-dist,y-min-dist),
                  ; va akharin H ke gharar dasht , yek aminoe dige bood , oonvaght in noghte ham Disable beshe
                  let lasthx matrix:get LAST-H-MATRIX 0 1
                  let lasthy matrix:get LAST-H-MATRIX 0 2

                  ;PRINT "X,Y-min-dist"
                  ;PRINT x-min-dist
                  ;PRINT y-min-dist

                  ;PRINT "lasthx,y"
                  ;PRINT lasthx
                  ;PRINT lasthy
;
                  set dim-list matrix:dimensions HP-List
                  set dim-array array:from-list dim-list
                  set j array:item dim-array 0
                  let i 0


                  let diff 0

                  if lasthx = x-min-dist
                  [;--- 1
                    ;print "lasthx = x-min-dist"
                    ifelse y-min-dist > lasthy
                    [
                      ;print "y-min-dist > lasthy"
                      set diff y-min-dist - lasthy
                    ]
                    [
                      ;print "y-min-dist < lasthy"
                      set diff lasthy - y-min-dist
                    ]
                    set diff diff - 2
;                    print "Diff"
;                    print Diff
;

                    while [diff > 0]
                    [
                      ifelse y-min-dist > lasthy
                      [
                        set stk1 lasthy + 2
                      ]
                      [
                        set stk1 lasthy - 2
                      ]

                      let matrix-item 0
                      set i 0
                      while [ i < j ]
                      ;       0    8
                      [
                        set matrix-item matrix:get HP-List i 1
                        if matrix-item = lasthx
                        [
                          set matrix-item matrix:get HP-List i 2
                          if stk1 = matrix-item
                          [
                            matrix:set CP-list-matrix min-dist-index 0 0
                            set placement-done 0
                            set boroberim 0
                            ;PRINT "CP DISABLING for ???"
                          ]
                        ]
                        set i i + 1
                      ]
                      set diff diff - 2
                    ]
                  ];--- 1


                  if lasthY = Y-min-dist
                  [;--- 1
                    ifelse x-min-dist > lasthx
                    [
                      set diff x-min-dist - lasthx
                    ]
                    [
                      set diff lasthx - x-min-dist
                    ]
                    set diff diff - 2

                    while [diff > 0]
                    [
                      ifelse x-min-dist > lasthx
                      [
                        set stk1 lasthx + 2
                      ]
                      [
                        set stk1 lasthx - 2
                      ]

                      let matrix-item 0
                      set i 0
                      while [ i < j ]
                      ;       0    8
                      [
                        set matrix-item matrix:get HP-List i 2
                        if matrix-item = lasthy
                        [
                          set matrix-item matrix:get HP-List i 1
                          if stk1 = matrix-item
                          [
                            matrix:set CP-list-matrix min-dist-index 0 0
                            set placement-done 0
                            set boroberim 0
                            ;PRINT "boroberim=0 , because of a hinder"
                          ]
                        ]
                        set i i + 1
                      ]
                      set diff diff - 2
                    ]
                  ];--- 1


                  ;==============================================================
                  ;==============================================================
                  ; inja check mikonim noghteye candid aya hade aghal ye hamsayegi khali dare?
                  ;#OK22
                  set x-gen x-min-dist
                  set y-gen y-min-dist
                  ;--------------------------------------
                  ; Then Create a list of Four possible places around it
                  ;--------------------------------------
                  ; Here, we create a list called "neighbour-clearence", and set all of its items to one
                  set stk1 1
                  set neighbour-clearence []
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  ;--------------------------------------
                  ; Then turn that list to an array
                  ;set neighbour-array array:from-list neighbour-clearence
                  ;--------------------------------------
                  set neighbour-array array:from-list neighbour-clearence
                  check-neighbour
                  ; Now we know which neighbourhood of the candidate position is occupied
                  set i 0
                  let av-counter 0
                  while [i < 4]
                  [
                    set stk1 array:item neighbour-array i
                    if stk1 = 1
                    [
                      set av-counter av-counter + 1
                    ]
                    set i i + 1
                  ]
                  if av-counter < 2
                  [
                    matrix:set CP-list-matrix min-dist-index 0 0
                    set placement-done 0
                    set boroberim 0
                    ;PRINT "boroberim=0 , because destination vacancy < 2"
                  ]

                  ;==============================================================
                  ;==============================================================
                  ; inja check mikonim age H bere be noghteye candid aya baraye
                  ; H ghabli hich hamsayegi khali baghi mimoone ke az oonja P ha ro beshe ghara dad
                  ; ;#OK23
                  ;noghte H ghabli
                  set x-gen matrix:get LAST-H-MATRIX 0 1
                  set y-gen matrix:get LAST-H-MATRIX 0 2

                  set stk1 1
                  set neighbour-clearence []
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence
                  set neighbour-clearence lput stk1 neighbour-clearence

                  ;PRINT "Checking CP-List for last H"
                  ;PRINT CP-List-Matrix
                  ;
                  set neighbour-array array:from-list neighbour-clearence
                  check-neighbour
                  ; Now we know which neighbourhood of the candidate position is occupied
                  set i 0
                  set av-counter 0
                  while [i < 4]
                  [
                    set stk1 array:item neighbour-array i
                    if stk1 = 1
                    [
                      set av-counter av-counter + 1
                    ]
                    set i i + 1
                  ]
                  if av-counter = 1
                  [
                    set i 0
                    while [i < 4]
                    [
                      set stk1 array:item neighbour-array i
                      if stk1 = 1
                      [
                        if i = 0
                        [
                          set y-gen y-gen + 2
                        ]
                        if i = 1
                        [
                          set x-gen x-gen + 2
                        ]

                        if i = 2
                        [
                          set y-gen y-gen - 2
                        ]
                        if i = 3
                        [
                          set x-gen x-gen - 2
                        ]

                        if x-gen = x-min-dist
                        [
                          if y-gen = y-min-dist
                          [
                            matrix:set CP-list-matrix min-dist-index 0 0
                            set placement-done 0
                            set boroberim 0
                            ;PRINT "Disbaled CP, BECAUSE OF 0 neighbors "
                            ;PRINT cp-list-matrix
                          ]

                        ]

                      ]
                      set i i + 1
                    ]

                  ]
                  ;==============================================================
                  ;==============================================================
                  ; Inja test mikonim agar H ro dar makane feli (X,Y-min-dist) begozarim
                  ; aya baes mishe ke toole link ha gheire mojaz beshe , age intor beshe
                  ; oon CP ro gheire mojaz mikonim
                  ; #?
                  if boroberim = 1
                  [
                  ;PRINT "--------------- start"
                  ;PRINT "Counter"
                  ;PRINT Counter
                  ;PRINT "last-h-matrix"
                  ;PRINT last-h-matrix

                  ;PRINT "x,y-min-dist"
                  ;PRINT x-min-dist
                  ;PRINT y-min-dist

                  ;PRINT "Last-h-1"
                  ;PRINT Last-h-1
                  ;PRINT "HP-List"
                  ;PRINT matrix:pretty-print-text HP-list

                  ;PRINT "CP-List-Matrix"
                  ;PRINT matrix:pretty-print-text CP-list-Matrix

                  ;PRINT "---------------end"

                  ; #OK24
                    ;PRINT "Moving amino () , to x,y"
                    ;PRINT counter
                    ;PRINT x-min-dist
                    ;PRINT y-min-dist

                    ask turtle counter [setxy x-min-dist y-min-dist]

                    ; This should be postponed to after P-Placement
                    ;--------------------------------------
                    ;matrix:set LAST-H-MATRIX 0 0 counter
                    ;matrix:set LAST-H-MATRIX 0 1 x-min-dist
                    ;matrix:set LAST-H-MATRIX 0 2 y-min-dist

                    set Last-H-1 matrix:get LAST-H-MATRIX 0 0


                    let Last-L-index matrix:get LAST-H-MATRIX 0 0



                    let LH-x x-min-dist
                    let LH-y y-min-dist

                    ;PRINT "Counter = "
                    ;PRINT Counter
                    ;PRINT "LH-x  = "
                    ;PRINT LH-x
                    ;PRINT "LH-Y  = "
                    ;PRINT LH-Y

                    ; Backup of current X,y of that turtle, IF move is unsuccessful , then
                    ; - setxy of that turtle to (turtle-x,y-backup) (move)
                    ; - set that coordination in (HP-list) again
                    let turtle-x-BU matrix:get HP-List counter 1
                    let turtle-y-BU matrix:get HP-List counter 2
                    ; 2- Set turtle new place in HP_LIST
                    matrix:set HP-List counter 1 x-min-dist
                    matrix:set HP-List counter 2 y-min-dist



;                    print "move H when they are match"
;                    print matrix:pretty-print-text HP-List
                    let Last-place-x-bu Last-place-x
                    let Last-place-y-bu Last-place-y
                    set Last-place-x x-min-dist
                    set Last-place-y y-min-dist

                    let Last-Xcor-BU Last-Xcor
                    let Last-Ycor-BU Last-Ycor
                    set Last-Xcor x-min-dist
                    set Last-ycor y-min-dist

                    ;PRINT "before placing Ps"
                    ;PRINT matrix:pretty-print-text HP-List
                    ;#inja
                    ;====================================================================================
                    ;====================================================================================

                  ; #OK25

                  ; 3-Move Ps between them to their place
                  ; first we identify how many P should we move
                  set stk1 matrix:get last-h-matrix 0 0


                  ;PRINT "++++++++++++++"
                  ;PRINT "Before calculating P-PL"
                  ;PRINT "LAST-H-MATRIX"
                  ;PRINT last-h-matrix
                  ;PRINT "H-1 index  = "
                  ;PRINT stk1
                  ;PRINT "Counter  = "
                  ;PRINT Counter
                  ;PRINT "LH-X  = "
                  ;PRINT LH-X
                  ;PRINT "LH-Y  = "
                  ;PRINT LH-Y




                  let P-PL counter - stk1
                  set P-PL P-PL - 1 ;(P-PL: P PLacements)


                  ;PRINT "P-PL  = "
                  ;PRINT P-PL
                  ;

                  ; #OK26
                  ; to find our approach to real last H ,We get x,y of last H , then put it to Previous-Amino-x,y
                  let Previous-Amino-x matrix:get last-h-matrix 0 1
                  let Previous-Amino-Y matrix:get last-h-matrix 0 2

                  ; Now We should find the Index of the P that should move
                  set P-PL-Index matrix:get last-h-matrix 0 0
                  Set P-PL-Index P-PL-Index + 1
                  Let P-PL-Index-backup P-PL-Index
                  ;-------------------------------

                  let PPL-index P-PL-Index
                  Let PPL P-PL


                  ;PRINT "Previous-Amino-x = "
                  ;PRINT Previous-Amino-x
                  ;PRINT "Previous-Amino-Y = "
                  ;PRINT Previous-Amino-Y

                  ;PRINT "P-PL-INDEX= "
                  ;PRINT P-PL-INDEX

                  let best-x 0
                  let best-y 0
                  ; #inja



                  ; #OK26
                    while [P-PL > 0]
                    [
                      ;PRINT "P movement, for P-PL ="
                      ;PRINT P-PL
                      ;;PRINT "------"
                      ; 1- Here : We find vacant neighbors of last-amino

                      ; #OK27
                      ;--------------------------------------
                      ; Firstly, get coordination of Last H , and put it into (x-gen,y-gen)
                      set x-gen Previous-Amino-x
                      set y-gen Previous-Amino-Y


                      set stk1 1
                      set neighbour-clearence []
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence

                      set neighbour-array array:from-list neighbour-clearence

                      check-neighbour
                      ;--------------------------------------
                      ;;PRINT neighbour-array

                      ; Create a backup from this array :
                      set neighbour-array-backup neighbour-array
                      set not-valid-item 0

                      ;PRINT "Index "
                      ;PRINT P-PL-INDEX
                      ;PRINT neighbour-array

                      ; 2- From Vacant (Available) positions , find the closest one
                      let xx 0
                      let yy 0
                      set min-dist 100
                      set best-x 0
                      set best-y 0
                      let first-time 0
                      ;-------------------
                      ; Reading N     (x,y+2)
                      set stk1 array:item neighbour-array 0

                      if stk1 = 1
                      [;4b
                       ; North
                       ;--------------------
                        ifelse LH-x > X-gen
                        [
                          set xx LH-x - x-gen
                        ]
                        [
                          set xx x-gen - LH-x
                        ]
                        set xx xx ^ 2
                        ;--------------------
                        set stk1 y-gen + 2
                        ifelse LH-y > stk1
                        [
                          set yy LH-y - stk1
                        ]
                        [
                          set yy stk1 - LH-y
                        ]
                        set yy yy ^ 2
                        ;--------------------
                        set stk1 yy + xx
                        set stk1 sqrt stk1
                        ;--------------------
                        ifelse first-time = 0
                        [
                          set min-dist stk1
                          set best-x x-gen
                          set best-y y-gen + 2
                          set first-time 1
                          set not-valid-item 0
                          ;PRINT "N selected "
                          ;PRINT "min-dist"
                          ;PRINT min-dist
                          ;PRINT best-x
                          ;PRINT best-y
                        ]
                        [
                          if stk1 < min-dist
                          [
                            ;PRINT "N selected "
                            set min-dist stk1
                            set best-x x-gen
                            set best-y y-gen + 2
                            set not-valid-item 0
                            ;PRINT min-dist
                            ;PRINT best-x
                            ;PRINT best-y
                          ]
                        ]
                      ];4b

                       ;-------------------
                       ; Reading E     (x+2,y)
                      set stk1 array:item neighbour-array 1
                      if stk1 = 1
                      [;4c

                        set stk1 x-gen + 2
                        ifelse LH-x > stk1
                        [
                          set xx LH-x - stk1
                        ]
                        [
                          set xx stk1 - LH-x
                        ]
                        set xx xx ^ 2
                        ;-------------------

                        ifelse LH-y > y-gen
                        [
                          set yy LH-y - y-gen
                        ]
                        [
                          set yy y-gen - LH-y
                        ]
                        set yy yy ^ 2
                        set stk1 yy + xx
                        set stk1 sqrt stk1
                        ifelse first-time = 0
                        [
                          ;PRINT "E selected "
                          set min-dist stk1
                          set best-x x-gen + 2
                          set best-y y-gen
                          set first-time 1
                          set not-valid-item 1
                          ;PRINT min-dist
                          ;PRINT best-x
                          ;PRINT best-y
                        ]
                        [
                          if stk1 < min-dist
                          [
                            ;PRINT "E selected "
                            set min-dist stk1
                            set best-x x-gen + 2
                            set best-y y-gen
                            set not-valid-item 1
                            ;PRINT min-dist
                            ;PRINT best-x
                            ;PRINT best-y
                          ]
                        ]
                      ];4c

                       ;-------------------
                       ; Reading S        (x,y-2)

                      set stk1 array:item neighbour-array 2
                      if stk1 = 1
                      [;4d

                        ifelse  LH-x > x-gen
                        [
                          set xx LH-x - x-gen
                        ]
                        [
                          set xx x-gen - LH-x
                        ]
                        set xx xx ^ 2


                        set stk1 y-gen - 2
                        ifelse LH-y > stk1
                        [
                          set yy LH-y - stk1
                        ]
                        [
                          set yy stk1 - LH-y
                        ]
                        set yy yy ^ 2


                        set stk1 yy + xx
                        set stk1 sqrt stk1
                        ifelse first-time = 0
                        [
                          ;PRINT "S selected "
                          set min-dist stk1
                          set best-x x-gen
                          set best-y y-gen - 2
                          set first-time 1
                          set not-valid-item 2
                          ;PRINT min-dist
                          ;PRINT best-x
                          ;PRINT best-y
                        ]
                        [
                          if stk1 < min-dist
                          [
                            ;PRINT "S selected "
                            set min-dist stk1
                            set best-x x-gen
                            set best-y y-gen - 2
                            set not-valid-item 2
                            ;PRINT min-dist
                            ;PRINT best-x
                            ;PRINT best-y
                          ]
                        ]
                      ];4d

                       ;-------------------
                       ; Reading W        (x-2,y2)
                      set stk1 array:item neighbour-array 3
                      if stk1 = 1
                      [;4e
                        set stk1 x-gen - 2

                        ifelse LH-X > Stk1
                        [
                          set xx LH-X - stk1
                        ]
                        [
                          set xx stk1 - LH-X
                        ]
                        set xx xx ^ 2

                        ifelse LH-y > y-gen
                        [
                          set yy LH-y - y-gen
                        ]
                        [
                          set yy y-gen - LH-y
                        ]
                        set yy yy ^ 2
                        set stk1 yy + xx
                        set stk1 sqrt stk1
                        ifelse first-time = 0
                        [
                          ;PRINT "W selected "
                          set min-dist stk1
                          set best-x x-gen - 2
                          set best-y y-gen
                          set first-time 1
                          set not-valid-item 3
                          ;PRINT min-dist
                          ;PRINT best-x
                          ;PRINT best-y
                        ]
                        [
                          if stk1 < min-dist
                          [
                            ;PRINT "W selected "
                            set min-dist stk1
                            set best-x x-gen - 2
                            set best-y y-gen
                            set not-valid-item 3
                            ;PRINT min-dist
                            ;PRINT best-x
                            ;PRINT best-y
                          ]
                        ]
                      ];4e

                     ;========================================================================
                     ;========================================================================
                     ; 3- Checking if the candidate position is right or not
                     ;---------------------------------------------------------
                     ; Here : We have found vacant neighbors of last-amino , and also found closest one to last H
                     ; Now we want to be sure that this point is a good choice , after assessing its neighbors availablity
                     ;--------------------------------------

                     ; #OK28

                     ; Firstly, get coordination of Last H , and put it into (x-gen,y-gen)
                      set x-gen best-x
                      set y-gen best-y
                      ;--------------------------------------
                      ; Then Create a list of Four possible places around it
                      ;--------------------------------------
                      ; Here, we create a list called "neighbour-clearence", and set all of its items to one
                      set stk1 1
                      set neighbour-clearence []
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence
                      set neighbour-clearence lput stk1 neighbour-clearence
                      ;--------------------------------------
                      ; Then turn that list to an array
                      ;set neighbour-array array:from-list neighbour-clearence
                      ;--------------------------------------
                      set neighbour-array array:from-list neighbour-clearence
                      check-neighbour
                      ; Now we know which neighbourhood of the candidate position is occupied

                      set xx 0
                      set yy 0
                      ;set min-dist 0
                      ;set best-x 0
                      ;set best-y 0
                      set first-time 0
                      set av-counter 0
                      set i 0

                      ; Check the all 4 items of the "neighbor_clearence" to be sure that it has at least one vacant place
                      while [i < 4]
                      [
                        set stk1 array:item neighbour-array i
                        if stk1 = 1
                        [
                          set av-counter av-counter + 1
                        ]
                        set i i + 1
                      ]

                      ; #OK29

                      ; If it has no vacant place so the process of finding another candidate position should repeat
                      ifelse av-counter = 0
                      [
                        ;PRINT "AV = 0 !"
                        array:set neighbour-array-backup not-valid-item 0
                        ;-------------------
                        ; Reading N
                        set stk1 array:item neighbour-array-backup 0
                        if stk1 = 1
                        [;4b
                          set xx LH-x - x-gen
                          set xx xx ^ 2

                          set stk1 y-gen + 2
                          set yy LH-y - stk1
                          set yy yy ^ 2
                          set stk1 yy + xx
                          set stk1 sqrt stk1
                          ;
                          ifelse first-time = 0
                          [
                            set min-dist stk1
                            set best-x x-gen
                            set best-y y-gen + 2
                            set first-time 1
                            set not-valid-item 0
                          ]
                          [
                            if stk1 < min-dist
                            [
                              set min-dist stk1
                              set best-x x-gen
                              set best-y y-gen + 2
                              set not-valid-item 0
                            ]
                          ]
                        ];4b

                         ;-------------------
                         ; Reading E
                        set stk1 array:item neighbour-array-backup 1
                        if stk1 = 1
                        [;4c
                          set stk1 x-gen + 2
                          set xx LH-x - stk1
                          set xx xx ^ 2

                          set yy LH-y - y-gen
                          set yy yy ^ 2
                          set stk1 yy + xx
                          set stk1 sqrt stk1
                          ifelse first-time = 0
                          [
                            set min-dist stk1
                            set best-x x-gen + 2
                            set best-y y-gen
                            set first-time 1
                            set not-valid-item 1
                          ]
                          [
                            if stk1 < min-dist
                            [
                              set min-dist stk1
                              set best-x x-gen + 2
                              set best-y y-gen
                              set not-valid-item 1
                            ]
                          ]
                        ];4c

                         ;-------------------
                         ; Reading S

                        set stk1 array:item neighbour-array-backup 2
                        if stk1 = 1
                        [;4d

                          set xx LH-x - x-gen
                          set xx xx ^ 2

                          set stk1 y-gen - 2
                          set yy LH-y - stk1
                          set yy yy ^ 2
                          set stk1 yy + xx
                          set stk1 sqrt stk1
                          ifelse first-time = 0
                          [
                            set min-dist stk1
                            set best-x x-gen
                            set best-y y-gen - 2
                            set first-time 1
                            set not-valid-item 2
                          ]
                          [
                            if stk1 < min-dist
                            [
                              set min-dist stk1
                              set best-x x-gen
                              set best-y y-gen - 2
                              set not-valid-item 2
                            ]
                          ]
                        ];4d

                         ;-------------------
                         ; Reading W
                        set stk1 array:item neighbour-array-backup 3
                        if stk1 = 1
                        [;4e
                          set stk1 x-gen - 2
                          set xx LH-x - stk1
                          set xx xx ^ 2

                          set yy LH-y - y-gen
                          set yy yy ^ 2
                          set stk1 yy + xx
                          set stk1 sqrt stk1
                          ifelse first-time = 0
                          [
                            set min-dist stk1
                            set best-x x-gen - 2
                            set best-y y-gen
                            set first-time 1
                            set not-valid-item 3
                          ]
                          [
                            if stk1 < min-dist
                            [
                              set min-dist stk1
                              set best-x x-gen - 2
                              set best-y y-gen
                              set not-valid-item 3
                            ]
                          ]
                        ];4e
                      ]

                      [
                        ; #OK30
                        ; move turtle to that candidate position
                        ask turtle P-PL-Index [setxy best-x best-y]
                        matrix:set HP-List P-PL-Index 1 best-x
                        matrix:set HP-List P-PL-Index 2 best-y

                        ;PRINT "P with inex: "
                        ;PRINT P-PL-Index
                        ;PRINT "Moved. New HP-LIST:"
                        ;PRINT matrix:pretty-;PRINT-text HP-List

                        set Previous-Amino-x best-x
                        set Previous-Amino-Y best-y
                      ]
                      ;-----------------------------------
                      ;-----------------------------------
                      ; 4- Decrease P-PL

                      set P-PL P-PL - 1
                      set P-PL-Index P-PL-Index + 1

                    ]; while [P-PL > 0]



                  ;========================================================================
                    ;========================================================================
                    ; 6- just assuring that Ps are placed in right places (Link-Length=1)
                    ; #OK32
                    set i 0
                    let LL 0
                    let P-fine 1
                    ;while [P-fine = 0]
                    ;[
                      ;PRINT "PPL-INDEX , PPL"
                      ;print PPL-index
                      ;print PPL
                      while [ i <= PPL ]
                      [
                        let Prev-amino PPL-Index - 1
                        ;PRINT "Length between"
                        ;PRINT Prev-amino
                        ;PRINT PPL-INDEX

                        ask link Prev-amino PPL-INDEX [ set LL link-length ]

                        ;PRINT "is"
                        ;PRINT LL

                        if LL != 2
                        [
                          set P-Fine 0
                          ;PRINT "Length not correct"
                        ]
                        set PPL-Index PPL-Index + 1
                        set i i + 1
                      ]
                      ; PPL-INDEX= 9 , PPL=4
                      ;---------------------
                      ;1- Link(7,8) , i=0  [ PPL-Index=PPL-Index + 1 =9 , i=i+1=1]
                      ;2- Link(8,9) , i=1  [ PPL-Index=PPL-Index + 1 =10 , i=i+1=2]
                      ;3- Link(10,9), i=2
                    ;]

                    ;print "last-h-matrix ,  Last-H-1"
                    ;print Last-h-matrix
                    ;print Last-H-1

                    ; #OK33

                    if P-Fine = 0
                    [
                       ;PRINT "No vacancy!"
                       matrix:set CP-list-matrix min-dist-index 0 0
                       set placement-done 0
                       set boroberim 0

                       ask turtle counter [setxy turtle-x-BU turtle-y-BU]

                       matrix:set HP-List counter 1 turtle-x-BU
                       matrix:set HP-List counter 2 turtle-y-BU

                       set Last-place-x Last-place-x-bu
                       set Last-place-y Last-place-y-bu

                       set Last-Xcor Last-Xcor-BU
                       set Last-ycor Last-Ycor-BU

                    ] ;if P-Fine = 0
                  ]

                  ;==============================================================
                  ;==============================================================
                  ; 1- Move This H to the candidate CP
                  if boroberim = 1
                  [
                    ; #OK24
;                    ;PRINT "Moving amino () , to x,y"
;                    ;PRINT counter
;                    ;PRINT x-min-dist
;                    ;PRINT y-min-dist
                    ask turtle counter [setxy x-min-dist y-min-dist]

                    ; This should be postponed to after P-Placement
                    ;--------------------------------------
                    ;matrix:set LAST-H-MATRIX 0 0 counter
                    ;matrix:set LAST-H-MATRIX 0 1 x-min-dist
                    ;matrix:set LAST-H-MATRIX 0 2 y-min-dist

                    set Last-H-1 matrix:get LAST-H-MATRIX 0 0


                    let Last-L-index matrix:get LAST-H-MATRIX 0 0

                    let LH-x x-min-dist
                    let LH-y y-min-dist

;                    ;PRINT "Counter = "
;                    ;PRINT Counter
;                    ;PRINT "LH-x  = "
;                    ;PRINT LH-x
;                    ;PRINT "LH-Y  = "
;                    ;PRINT LH-Y
;

                    ;PRINT "Last-h-1"
                    ;PRINT Last-H-1

                    ; 2- Set turtle new place in HP_LIST
                    matrix:set HP-List counter 1 x-min-dist
                    matrix:set HP-List counter 2 y-min-dist

                    ;PRINT "moving H when they are match"
                    ;PRINT matrix:pretty-print-text HP-List

                    set Last-place-x x-min-dist
                    set Last-place-y y-min-dist

                    set Last-Xcor x-min-dist
                    set Last-ycor y-min-dist
                    ;#inja
                    ;====================================================================================
                    ;====================================================================================

                    ; #OK31
                     ;=========
                     ; 4- Update (Last-xcor,Last-ycor)
                    set last-xcor x-min-dist
                    set last-ycor y-min-dist

                    set last-place-x x-min-dist
                    set last-place-y y-min-dist

                    set stk1 P-PL-Index

                    matrix:set last-h-matrix 0 0 stk1
                    matrix:set last-h-matrix 0 1 x-min-dist
                    matrix:set last-h-matrix 0 2 y-min-dist

                    ; 5- Set placement_done=1, ....
                    set placement-done 1


                    set counter counter + 1
                    set p-counter 0
;


                    ; ideye inja : in bar az akhar miam aval
                    ;  1- hamsayegi haye khalie H badi ro peida mikonim (shomare n)
                    ;  2- ooni ke be H ghabli nazdiktare ro entekhab mikonim ((n-1) ro dar hamsayegie candide n mizarim)
                    ;  3- (ba tavajoh be inke hala Linke in amino ta aminoe
                    ;      ghabli 100% barabre 2 hast (n-1,n)) alan andazeye linke (n-2) ta n-1 ro mohasebe mikonim
                    ;  4- agar mosavie 2 bood mirim roo aminoe badi yani (n-3)
                    ;  4'- agar (Length > 2) bood  , dobare hamsayegie khalie  (n-1) ro peida mikonim va edame ta vaghti kole P haie beine dota H ro peimoode bashim

                    ;PRINT "LAST-H-MATRIX"
                    ;PRINT LAST-H-MATRIX


                    set x-gen matrix:get Last-H-Matrix 0 1
                    set y-gen matrix:get Last-H-Matrix 0 2

                    set neighbour-clearence []
                    set stk1 1
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-clearence lput stk1 neighbour-clearence
                    set neighbour-array array:from-list neighbour-clearence
                    check-neighbour

                    set i 0
                    let vacancy 0
                    while [i < 4]
                    [
                      set stk1 array:item neighbour-array i
                      if stk1 = 1
                      [
                        set vacancy vacancy + 1
                      ]
                      set i i + 1
                    ]
                    ;*******************
                    if vacancy = 0
                    [
                       ;PRINT "###VACANCY = 0"
                      ;let Amino-index PPL + PPL-INDEX - 1

                      ; Calculating remaining Ps to be placed
                      set stk1 matrix:get LAST-H-MATRIX 0 0
                      let pcounter stk1 - last-h-1
                      set pcounter pcounter - 1

                      ;PRINT "AMINO-INDEX"
                      ;PRINT STK1

                      ; Calculating last amino index which should be a center for neighborhood vacancy calculation
                      let amino-index stk1
                      ;PRINT "amino-index "
                      ;PRINT amino-index
                      ;PRINT "Pcounter"
                      ;PRINT pcounter

                      ; Displacing Ps from this wrong place they are
                      set stk2 amino-index - pcounter
                      while [stk2 < amino-index]
                      [
                        ;PRINT "Displacing amino-P:"
                        ;PRINT stk2

                        ; get x,y of each one
                        set X-gen matrix:get HP-LIST stk2 1
                        set Y-gen matrix:get HP-LIST stk2 2
                        ;
                        set Y-gen Y-gen + 20
                        ask turtle stk2 [setxy X-gen Y-gen]
                        matrix:set HP-List stk2 1 X-gen
                        matrix:set HP-List stk2 2 Y-gen


                        set stk2 stk2 + 1
                      ]

                      ;set amino-index amino-index + 1

                      while [pcounter > 0]
                      [
                        ; Get coordination of this point , and make neighborhood list
                        set X-gen matrix:get HP-LIST amino-index 1
                        set Y-gen matrix:get HP-LIST amino-index 2
                        set stk1 1
                        set neighbour-clearence []
                        set neighbour-clearence lput stk1 neighbour-clearence
                        set neighbour-clearence lput stk1 neighbour-clearence
                        set neighbour-clearence lput stk1 neighbour-clearence
                        set neighbour-clearence lput stk1 neighbour-clearence
                        set neighbour-array array:from-list neighbour-clearence
                        check-neighbour
                        ;PRINT "____________"
                        ;PRINT "amino-index= "
                        ;PRINT amino-index
                        ;PRINT "X,Y-gen"
                        ;PRINT X-gen
                        ;PRINT Y-gen
                        ;PRINT "____________"
                        ;------------------------
                        ; - Here we should define Endpoint which is coordination of (last-h-1)
                        ;   and each start point that is CP coordination that the distance will
                        ;   be calculated
                        set LH-X matrix:get HP-LIST last-h-1 1
                        set LH-Y matrix:get HP-LIST last-h-1 2

                        let CP-X X-Gen
                        Let CP-Y Y-Gen
                        ;--------------------------
                        let p-placed 0
                        let xx 0
                        let yy 0
                        let First-time 0

                        let best-x 0
                        let best-y 0

                        while [ p-placed = 0 ]
                        [
                          ;PRINT "neighbour-array "
                          ;PRINT neighbour-array
                          ;PRINT "for amino-index= "
                          ;PRINT amino-index
                          set not-valid-item 5
                          set min-dist 100
                          ;-------------------
                          ; Reading N
                          set stk1 array:item neighbour-array 0
                          if stk1 = 1
                          [;4b
                            set xx LH-x - x-gen
                            set xx xx ^ 2
                            ;
                            set stk1 y-gen + 2
                            ;
                            set yy LH-y - stk1
                            set yy yy ^ 2
                            ;

                            set stk1 yy + xx
                            set stk1 sqrt stk1
                            ;PRINT "Distance from N:"
                            ;print stk1
                            ;
                            ifelse first-time = 0
                            [
                              set min-dist stk1
                              set best-x x-gen
                              set best-y y-gen + 2
                              set first-time 1
                              set not-valid-item 0
                              ;print "N is min_dist "
                            ]
                            [
                              if stk1 < min-dist
                              [
                                set min-dist stk1
                                set best-x x-gen
                                set best-y y-gen + 2
                                set not-valid-item 0
                                ;print "N is min_dist "
                              ]
                            ]
                          ];4b

                           ;-------------------
                           ; Reading E
                          set stk1 array:item neighbour-array 1
                          if stk1 = 1
                          [;4c
                            set stk1 x-gen + 2
                            ;
                            set xx LH-x - stk1
                            set xx xx ^ 2

                            set yy LH-y - y-gen
                            set yy yy ^ 2
                            ;
                            set stk1 yy + xx
                            set stk1 sqrt stk1
                            ;print "Distance from E:"
                            ;print stk1
                            ifelse first-time = 0
                            [
                              set min-dist stk1
                              set best-x x-gen + 2
                              set best-y y-gen
                              set first-time 1
                              set not-valid-item 1
                              ;print "E is min_dist "
                            ]
                            [
                              if stk1 < min-dist
                              [
                                set min-dist stk1
                                set best-x x-gen + 2
                                set best-y y-gen
                                set not-valid-item 1
                                ;print "E is min_dist "
                              ]
                            ]
                          ];4c

                           ;-------------------
                           ; Reading S

                          set stk1 array:item neighbour-array 2
                          if stk1 = 1
                          [;4d

                            set xx LH-x - x-gen
                            set xx xx ^ 2

                            set stk1 y-gen - 2
                            ;
                            set yy LH-y - stk1
                            set yy yy ^ 2
                            ;
                            set stk1 yy + xx
                            set stk1 sqrt stk1

                            ;print "Distance from S:"
                            ;print stk1

                            ifelse first-time = 0
                            [
                              set min-dist stk1
                              set best-x x-gen
                              set best-y y-gen - 2
                              set first-time 1
                              set not-valid-item 2
                              ;print "S is min_dist "
                            ]
                            [
                              if stk1 < min-dist
                              [
                                set min-dist stk1
                                set best-x x-gen
                                set best-y y-gen - 2

                                set not-valid-item 2
                                ;print "S is min_dist "
                              ]
                            ]
                          ];4d

                           ;-------------------
                           ; Reading W
                          set stk1 array:item neighbour-array 3
                          if stk1 = 1
                          [;4e
                            set stk1 x-gen - 2
                            ;
                            set xx LH-x - stk1
                            set xx xx ^ 2

                            set yy LH-y - y-gen
                            set yy yy ^ 2
                            ;
                            set stk1 yy + xx
                            set stk1 sqrt stk1
                            ;print "Distance from W:"
                            ;print stk1
                            ifelse first-time = 0
                            [
                              set min-dist stk1
                              set best-x x-gen - 2
                              set best-y y-gen
                              set first-time 1
                              set not-valid-item 3
                              ;print "W is min_dist "
                            ]
                            [
                              if stk1 < min-dist
                              [
                                set min-dist stk1
                                set best-x x-gen - 2
                                set best-y y-gen
                                set not-valid-item 3
                                ;print "W is min_dist "
                              ]
                            ]
                          ];4e

                          ;------------------
                          ; calculating distance , it should not be =2 if its not last amino
                          let dist-X 0
                          let dist-Y 0
                          ifelse best-X > LH-X
                          [
                            set dist-X best-x - LH-x
                          ]
                          [
                            set dist-X LH-X - best-x
                          ]

                          ifelse best-Y > LH-Y
                          [
                            set dist-Y best-Y - LH-y
                          ]
                          [
                            set dist-Y LH-Y - best-Y
                          ]
                          ;--------------
                          ;PRINT "LH-x,y"
                          ;PRINT LH-x
                          ;PRINT LH-Y

                          ;PRINT "Best-x,y"
                          ;PRINT Best-x
                          ;PRINT Best-Y

                          set stk1 dist-x + dist-y
                          ;PRINT "Distance from Last-h-1"
                          ;PRINT Stk1

                          ifelse stk1 > 2
                          [

                            set amino-index amino-index - 1
                            ask turtle amino-index [setxy best-x best-y]
                            matrix:set HP-List amino-index 1 best-x
                            matrix:set HP-List amino-index 2 best-y

                            set p-placed 1
                            set pcounter pcounter - 1
                            ;PRINT "Moving amino Index="
                            ;PRINT amino-index
                            ;PRINT "New Pcounter"
                            ;PRINT Pcounter
                          ]
                          [

                            ifelse pcounter = 1
                            [
                              set amino-index amino-index - 1
                              ask turtle amino-index [setxy best-x best-y]
                              matrix:set HP-List amino-index 1 best-x
                              matrix:set HP-List amino-index 2 best-y

                              set p-placed 1
                              set pcounter pcounter - 1
                              ;PRINT "Moving amino Index="
                              ;PRINT amino-index
                              ;PRINT "New Pcounter"
                              ;PRINT Pcounter
                             ]

                            [
                              array:set neighbour-array not-valid-item 0
                            ]
                          ]
                        ] ; while [ p-placed = 0 ]
                      ]; while [pcounter > 0]

                    ]; if vacancy = 0
                    ;--------------------


                  ]; if boroberim = 1
                ]
                 ; if p-counter < p-min , we can't put agent to that point beacuse the length
                 ;  between two point is not enough , so we'll disable that point
                [
                  matrix:set CP-list-matrix min-dist-index 0 0
                  set placement-done 0
                ]
              ]; If are match


              [
                ;==============
                ; -----------IF ARE-MATCH=0
                ; ---------------- DISABLE THAT CP
                ;PRINT "ARE NOT MATCH!"
                matrix:set CP-list-matrix min-dist-index 0 0
                set placement-done 0
                ; Not the Same
                ;  -     If ((P-counter is even and P_min is Odd) or (P-counter is odd and P_min is Even)) ->  (Disbale that point)
                ; now we should restart from the point of selecting
              ]; If are not match

            ];if min-dist < 100
          ];while [ placement-done = 0 ]
      ]; if p-counter > 0
    ] ;1 if amino is H
  ] ; while (counter < Seq-len )
  LET I 0
  ;print "HEREEEEEEEEEEEE"
  let previous-x 0
  let previous-y 0
  let N-x 0
  Let N-y 0
  WHILE [ I < SEQ-LEN]
  [
    ;PRINT " I loop: "
    ;PRINT I
    ; Reading Y of that
    let y matrix:get HP-List I 2
    if y < 10
    [
      ;PRINT "found an amino Not Joined"
      Let stk1 i - 1
      set previous-x matrix:get HP-List stk1 1
      set previous-y matrix:get HP-List stk1 2
      ;
      Set x-gen previous-x
      Set y-gen previous-y

      ;PRINT "PREVIOUS AMINO X,Y"
      ;PRINT previous-x
      ;PRINT previous-Y

      set stk1 1
      set neighbour-clearence []
      set neighbour-clearence lput stk1 neighbour-clearence
      set neighbour-clearence lput stk1 neighbour-clearence
      set neighbour-clearence lput stk1 neighbour-clearence
      set neighbour-clearence lput stk1 neighbour-clearence
      set neighbour-array array:from-list neighbour-clearence
      check-neighbour
      let nei-arr neighbour-array

      ;PRINT "PREVIOUS AMINO NEIGHBORHOOD"
      ;PRINT nei-arr

      Let good-point 0
      let j 0
      While [ good-point = 0  ]
      [
        ; 1- check neighborhood of this availabe point
        ; 2- Is a neighbor empty?
        ; 3- Does that vacant CP , have two available neighbor (to be able to k=continue the string)
        set stk1 array:item nei-arr j
        if stk1 = 1
        [
          if j = 0
          [
            ;PRINT "N IS VACANT, AND ITS NEIGHBOR ARRAY: "
            set N-Y previous-Y + 2
            set N-X previous-X
          ]
          if j = 1
          [
            ;PRINT "E IS VACANT, AND ITS NEIGHBOR ARRAY: "
            set N-x previous-x + 2
            set N-Y previous-Y
          ]
          if j = 2
          [
            ;PRINT "S IS VACANT, AND ITS NEIGHBOR ARRAY: "
            set N-Y previous-Y - 2
            set N-X previous-X
          ]
          if j = 3
          [
            ;PRINT "W IS VACANT , AND ITS NEIGHBOR ARRAY: "
            set N-X previous-x - 2
            set N-Y previous-Y
          ]

          Set x-gen N-X
          Set y-gen N-Y

          ;PRINT "N-X,Y"
          ;PRINT N-X
          ;PRINT N-Y

          set stk1 1
          set neighbour-clearence []
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-clearence lput stk1 neighbour-clearence
          set neighbour-array array:from-list neighbour-clearence
          check-neighbour
          ;
          ;PRINT NEIGHBOUR-ARRAY

          let k 0
          let empty-N 0
          while [ k < 4 ]
          [
            set stk1 array:item neighbour-array j
            set empty-N empty-N + 1
            set k k + 1
          ]
          ; now check , if it has at least two empty CP , take it as destination of movement
          if empty-N > 1
          [
            ;PRINT "IT HAS AT LEAST 2 VACANCY"
            ask turtle i [setxy N-X N-Y]
            ;matrix:set CP-list-matrix min-dist-index 0 0
            matrix:set HP-List i 1 N-X
            matrix:set HP-List i 2 N-Y
            ;PRINT matrix:pretty-;PRINT-text HP-List
            SET good-point 1
          ]
        ]
        set j j + 1
      ]
      ;;;;;;;zzzzzzzzzzzzzzzzzzzzzzz

    ]
    set i i + 1
  ]
  ;-------------------------------------------------- ENERGY
  ; Checking Links to assure every link are = 1

;  let dim-list matrix:dimensions HP-List
;  ; J= number of all rows, because we want to read all list to find
;  ;    a match with (X-Gen,Y-Gen) , and deactive that point
;  let dim-array array:from-list dim-list
;  let j array:item dim-array 0
;
;  let link-ok 1
;  let i 0
;  while [ i < j ]
;  [
;
;  ]
;  let xx 0
;  ask link 0 1 [ set xx link-length ]
;  ;PRINT xx
;  ask link 0 1 [ print link-heading ]
  set setup-time timer
  ;print timer
  ;---------------
  ;========================================
  ; Calculating Energy
  ; Print "+++++++ ENERGY"

  let dim-list matrix:dimensions HP-List
  let dim-array array:from-list dim-list
  let j array:item dim-array 0
  ;Print "J="
  ;print j

  set energyy 0
  set counter 0
  let xx 0
  let yy 0
  while [ counter < seq-len ]
  [
    let stk1 matrix:get HP-List counter 0
    ;print "Counter="
    ;print counter
    if stk1 = 1
    [
      set x-gen matrix:get HP-List counter 1
      set y-gen matrix:get HP-List counter 2

      ; Checking North
      set xx x-gen
      set yy y-gen + 2
      set i counter + 2
      while [i < j]
      [
        set stk1 matrix:get HP-List i 0
        if stk1 = 1
        [
          set stk1 matrix:get HP-List i 1
          if stk1 = xx
          [
            set stk1 matrix:get HP-List i 2
            if stk1 = yy
            [
              set energyy energyy + 1
              ;print "Energy between counter , i "
              ;print counter
              ;print i
            ]
          ]
        ]
        set i i + 1
      ]
      ;================================
      ; Checking East
      set xx x-gen + 2
      set yy y-gen
      set i counter + 2
      while [i < j]
      [
        set stk1 matrix:get HP-List i 0
        if stk1 = 1
        [
          set stk1 matrix:get HP-List i 1
          if stk1 = xx
          [
            set stk1 matrix:get HP-List i 2
            if stk1 = yy
            [
              set energyy energyy + 1
              ;print "Energy between counter , i "
              ;print counter
              ;print i
            ]
          ]
        ]
        set i i + 1
      ]
      ;================================
      ; Checking South
      set xx x-gen
      set yy y-gen - 2
      set i counter + 2
      while [i < j]
      [
        set stk1 matrix:get HP-List i 0
        if stk1 = 1
        [
          set stk1 matrix:get HP-List i 1
          if stk1 = xx
          [
            set stk1 matrix:get HP-List i 2
            if stk1 = yy
            [
              set energyy energyy + 1
              ;print "Energy between counter , i "
              ;print counter
              ;print i
            ]
          ]
        ]
        set i i + 1
      ]

      ;================================
      ; Checking West
      set xx x-gen - 2
      set yy y-gen
      set i counter + 2
      while [i < j]
      [
        set stk1 matrix:get HP-List i 0
        if stk1 = 1
        [
          set stk1 matrix:get HP-List i 1
          if stk1 = xx
          [
            set stk1 matrix:get HP-List i 2
            if stk1 = yy
            [
              set energyy energyy + 1
              ;print "Energy between counter , i "
              ;print counter
              ;print i
            ]
          ]
        ]
        set i i + 1
      ]




    ]
    set counter counter + 1
  ]
  ;set energyy energyy / 2
  set energy energyy * -1
  ;print matrix:pretty-print-text HP-List
  ;print CP-List-Matrix
  ;print "============================================================================================"
  ;print "============================================================================================"
end


to-report testing [ a b ]
  ifelse a < b
  [
  report a
  ]
  [
  report b
  ]
end

to check-neighbour
  let dim-list matrix:dimensions HP-List

  ; J= number of all rows, because we want to read all list to find
  ;    a match with (X-Gen,Y-Gen) , and deactive that point
  let dim-array array:from-list dim-list
  let j array:item dim-array 0
  let i 0
  ;------------------------------
  ; Now for each N,E,S,W check if any item in HP-List is located at the same location or not
  ; -------
  ; -> N
  ; (x-gn,y-gen)
  set y-gen y-gen + 2
  set i 0

  let stk1 0

  while [ i < j ]
  ;       0    13
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 0 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> E
  ; (x-gn,y-gen)
  set y-gen y-gen - 2 ; turn to original number
  set x-gen x-gen + 2 ; turn to East
  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 1 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> S
  ; (x-gn,y-gen)
  set y-gen y-gen - 2 ; turn to Down
  set x-gen x-gen - 2 ; turn to original number
  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 2 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> W
  ; (x-gn,y-gen)
  set y-gen y-gen + 2 ; turn to original number
  set x-gen x-gen - 2 ; turn to West
  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 3 0
      ]
     ]

    set i i + 1
  ]

   set x-gen x-gen + 2 ; turn to original point
end

to check-neighbour-odd
  let dim-list matrix:dimensions HP-List

  ; J= number of all rows, because we want to read all list to find
  ;    a match with (X-Gen,Y-Gen) , and deactive that point
  let dim-array array:from-list dim-list
  let j array:item dim-array 0
  let i 0
  ;------------------------------
  ; Now for each N,E,S,W check if any item in HP-List is located at the same location or not
  ; -------
  ; -> NE
  ; (x-gn,y-gen)
  set y-gen y-gen + 2
  set x-gen x-gen + 2
  set i 0

  let stk1 0

  while [ i < j ]
  ;       1    2
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 0 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> SE
  ; (x-gn,y-gen)
  set y-gen y-gen - 2 ; turn to original number
  set x-gen x-gen - 2 ; turn to original number

  set y-gen y-gen - 2 ; turn to down
  set x-gen x-gen + 2 ; turn to right

  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 1 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> SW
  ; (x-gn,y-gen)
  set y-gen y-gen + 2 ; turn to original number
  set x-gen x-gen - 2 ; turn to original number

  set y-gen y-gen - 2 ; turn to Down
  set x-gen x-gen - 2 ; turn to left
  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 2 0
      ]
     ]
    set i i + 1
  ]
  ; -------
  ; -> NW
  ; (x-gn,y-gen)
  set y-gen y-gen + 2 ; turn to original number
  set x-gen x-gen + 2 ; turn to original number

  set y-gen y-gen + 2 ; turn to down
  set x-gen x-gen - 2 ; turn to left
  set i 0

  set stk1 0

  while [ i < j ]
  [
    set stk1 matrix:get HP-List i 1
    if stk1 = x-gen
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-gen
      [
        array:set neighbour-array 3 0
      ]
     ]

    set i i + 1
  ]

   set x-gen x-gen + 2 ; turn to original point
   set Y-gen y-gen - 2 ; turn to original point
end

to pp
  ifelse sizze = 0
  [
    set size 1.3
    set sizze 1
  ]
  [
    set size 1
    set sizze 0
  ]

;  if  waiting
;  [
;    print "YYYYYYYYY"
;  ]


end


to MAS
    let mast-time 0
    reset-timer
    ;----------------------------------------------------
    ; $1
    ; copying current "HP-List" to "HP-List-Reference"
    let hp1 []
    let hp2 []
    let dim-list matrix:dimensions HP-List
    let dim-array array:from-list dim-list
    let j array:item dim-array 0
    let i 0
    while [ i < j ]
    [
      let stk1 matrix:get HP-List i 0
      set hp1 lput stk1 hp1
      set stk1 matrix:get HP-List i 1
      set hp1 lput stk1 hp1
      set stk1 matrix:get HP-List i 2
      set hp1 lput stk1 hp1
      ; [ x,y,z ]
      set hp2 lput hp1 hp2
      set hp1 []
      set i i + 1
    ]
    set HP-List-reference matrix:from-row-list hp2


    let it-counter 0


    ;$2
    let Reset 0
    set energy-old energy
    Let Temp T
    set current-temp T
    ;show "in mas"
    ;show Temp

    ;show energy-old
    set links-ok 0
    ;---------------------- ------------------------------
    ;$3
    while [ current-temp > stop-temp or links-ok = 0 ]
    [
      update-plots
      ;---------
      ; ==================================================
      ; ==================================================
      ;  UPDATING H-CENTER
      ;
      ; 1- Update H_Center (its a (x,y) that shows the center point of all Hs)(it is calculated from HP_LIST)
      ; ; #OK2
      let ss 0
      let stk1 0
      let stk2 0
      let stk3 0
      let add-x 0
      let add-y 0
      let num 0
      ;set stk3 counter - 1
      while [ss < seq-len]
      ;       0     4
      [;3a
       ; Read type of amino from HP_LIST
        set stk1 matrix:get HP-List ss 0 ; reads first(0) item from row=ss of HP-List

                                         ; If it is H ...
        if stk1 = 1
        [;4b
         ; Read its X , add to ADD_X
          set stk2 matrix:get HP-List ss 1
          set add-x add-x + stk2
          ; Read its Y , add to ADD_Y
          set stk2 matrix:get HP-List ss 2
          set add-y add-y + stk2

          ; Increase denumrator
          set num num + 1
        ];4b
        set ss ss + 1
      ];3a

      let H-center-x add-x / num
      let H-center-y add-y / num

      ;type "H-Center-X= " type h-center-x type " , H-Center-Y= " print h-center-y
      ;-------------------------------------------------------
      ;-------------------------------------------------------
      ;  2- Randomly select a H/P
     ;print  "++++++++++++++++++++++++++++++++++++++++++++++++"
      ;type "it-counter = " type it-counter print " "
      set it-counter it-counter + 1

      let amino-ok 0 ; amino_ok is 0 unless it has found an amino(H/P) that CAN move to a valid location
      ; it says that: try to find a H/P unless it has found a valid place to move
      let f-move 0
      let pos 0
      let x-amino 0
      let y-amino 0
      set j 0
      while [ amino-ok = 0 ]
      [
       ;print  "+++ AMINO-OK = 0 "

        let RR random-float 1

        let h-opted 0

        ifelse RR > H-Chance
        [
          while [h-opted = 0]
          [
            set f-move random seq-len  ; f-move is the index of first aminoacid selcted for a random move
                                       ; select a number as index randomly, to move a
                                       ;
                                       ;---------
                                       ; 3- (or Randomly) if selected Amino is H, tend to be closer to H-ceter , esle , tend to be farther to H-Center , (set LAST_MOVED_INDEX)
            let typee matrix:get HP-List f-move 0
            set h-opted typee
          ]
        ]

        [
          while [h-opted = 0]
          [
            set f-move random seq-len  ; f-move is the index of first aminoacid selcted for a random move
                                       ; select a number as index randomly, to move a
                                       ;
                                       ;---------
                                       ; 3- (or Randomly) if selected Amino is H, tend to be closer to H-ceter , esle , tend to be farther to H-Center , (set LAST_MOVED_INDEX)
            let typee matrix:get HP-List f-move 0
            ifelse typee = 0
            [
              set h-opted 1
            ]
            [
              set h-opted 0
            ]
          ]

        ]

        ;type "Randomly selected f-move=" Print f-move


        if animation
        [
          display wait anime-delay
        ]

        let typee matrix:get HP-List f-move 0
        ;===============================
        ifelse typee = 0 ; If amino is 'P'
        [
          ;print " Amino type is  -P-"

          let maxx 0
          let maxx-index 100
          ;---------------------------------------------------------------------
          ; making a list ( possible_p=[1,1,1,1] ) for possible movements for P
          let list-1 []
          let a 1
          set list-1 lput a list-1
          set list-1 lput a list-1
          set list-1 lput a list-1
          set list-1 lput a list-1
          let list-2 []
          set list-2 lput list-1 list-2
          let possible-p matrix:from-row-list list-2

          ; making a list ( dist_p=[0,0,0,0] ) for distance measurement
          set list-1 []
          set a 0
          set list-1 lput a list-1
          set list-1 lput a list-1
          set list-1 lput a list-1
          set list-1 lput a list-1
          set list-2 []
          set list-2 lput list-1 list-2
          let dist-p matrix:from-row-list list-2
          ;---------------------------------------------------------------------

          ; get position of selected amino
          let orig-x matrix:get HP-List f-move 1
          let orig-y matrix:get HP-List f-move 2

          ;---------------------------------------
          ; 1- Checking for NE
          set x-vac orig-x + 2
          set y-vac orig-y + 2
          ; test if this point is vacant

          vacancy-test

          ifelse isVacant = 0
          [
           ;print " P-NE is not vacant"
            matrix:set possible-p 0 0 0
          ]

          [
           ;print " P-NE is Vacant"
            set stk1 x-vac
            set stk2 y-vac

            ifelse stk1 >= h-center-x
            [
              set stk1 stk1 - h-center-x
            ]
            [
              set stk1 h-center-x - stk1
            ]

            ifelse stk2 >= h-center-y
            [
              set stk2 stk2 - h-center-y
            ]
            [
              set stk2 h-center-y - stk2
            ]
            ; Here we calculate the distance between current Point to H-Center
            set stk1 stk1 * stk1
            set stk2 stk2 * stk2
            set stk3 stk1 + stk2
            set stk3 sqrt stk3

            ; Now we put it in cp-dist list
            matrix:set dist-p 0 0 stk3
            ;type "Distant matrix(NE): " print dist-p
          ]

          ;---------------------------------------
          ; 1- Checking for SE
          set x-vac orig-x + 2
          set y-vac orig-y - 2
          ; test if this point is vacant

          vacancy-test

          ifelse isVacant = 0
          [
           ;print " P-SE is not vacant"
            matrix:set possible-p 0 1 0
          ]
          [
           ;print " P-SE is vacant"
            set stk1 x-vac
            set stk2 y-vac

            ifelse stk1 >= h-center-x
            [
              set stk1 stk1 - h-center-x
            ]
            [
              set stk1 h-center-x - stk1
            ]

            ifelse stk2 >= h-center-y
            [
              set stk2 stk2 - h-center-y
            ]
            [
              set stk2 h-center-y - stk2
            ]
            ; Here we calculate the distance between current Point to H-Center
            set stk1 stk1 * stk1
            set stk2 stk2 * stk2
            set stk3 stk1 + stk2
            set stk3 sqrt stk3

            ; Now we put it in cp-dist list
            matrix:set dist-p 0 1 stk3
            ;type "Distant matrix(SE): " print dist-p
          ]

          ;---------------------------------------
          ; 1- Checking for SW
          set x-vac orig-x - 2
          set y-vac orig-y - 2
          ; test if this point is vacant

          vacancy-test

          ifelse isVacant = 0
          [
           ;print " P-SW is not vacant"
            matrix:set possible-p 0 2 0
          ]
          [
           ;print " P-Sw is vacant"
            set stk1 x-vac
            set stk2 y-vac

            ifelse stk1 >= h-center-x
            [
              set stk1 stk1 - h-center-x
            ]
            [
              set stk1 h-center-x - stk1
            ]

            ifelse stk2 >= h-center-y
            [
              set stk2 stk2 - h-center-y
            ]
            [
              set stk2 h-center-y - stk2
            ]
            ; Here we calculate the distance between current Point to H-Center
            set stk1 stk1 * stk1
            set stk2 stk2 * stk2
            set stk3 stk1 + stk2
            set stk3 sqrt stk3

            ; Now we put it in cp-dist list
            matrix:set dist-p 0 2 stk3
            ;type "Distant matrix(SW): " print dist-p
          ]

          ;---------------------------------------
          ; 1- Checking for NW
          set x-vac orig-x - 2
          set y-vac orig-y + 2
          ; test if this point is vacant

          vacancy-test

          ifelse isVacant = 0
          [
           ;print " P-NW is not vacant"
            matrix:set possible-p 0 3 0
          ]
          [
           ;print " P-NW is vacant"
            set stk1 x-vac
            set stk2 y-vac

            ifelse stk1 >= h-center-x
            [
              set stk1 stk1 - h-center-x
            ]
            [
              set stk1 h-center-x - stk1
            ]

            ifelse stk2 >= h-center-y
            [
              set stk2 stk2 - h-center-y
            ]
            [
              set stk2 h-center-y - stk2
            ]
            ; Here we calculate the distance between current Point to H-Center
            set stk1 stk1 * stk1
            set stk2 stk2 * stk2
            set stk3 stk1 + stk2
            set stk3 sqrt stk3

            ; Now we put it in cp-dist list
            matrix:set dist-p 0 3 stk3
            ;type "Distant matrix(NW): " print dist-p
          ]

          set i 0
          set maxx 0
          set maxx-index 100
          ; serach for maximuum distance to H-Center
          while [i < 4]
          [
            let dist matrix:get dist-p 0 i
            if dist > maxx
            [
              set maxx dist
              set maxx-index i
            ]
            set i i + 1
          ]
          set pos maxx-index
          ;type "Max.dist.=" type maxx type "  , max.index=" print maxx-index
        ]
        ;======================
        [
         ;print " Amino is --H--"
          let selected 0
          let minn 100
          let minn-index 100
          ;---------------------------------------------------------------------
          ; get position of selected amino
          let orig-x matrix:get HP-List f-move 1
          let orig-y matrix:get HP-List f-move 2
          ;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
          ;---------------------------------------
          ; 1- Checking for __ NE __
          set x-vac orig-x + 2
          set y-vac orig-y + 2
          ; test if this point is vacant
          vacancy-test
          set HP-typee 0
          if isVacant = 1
          [
            ; Check NE-N
            set x-vac orig-x + 2
            set y-vac orig-y + 4
            HP-Test
            if HP-Typee = 1
            [
             ;print " NE-N is selected "
              set pos 0
              set selected 1
            ]
            ; Check NE-E
            set x-vac orig-x + 4
            set y-vac orig-y + 2
            HP-Test
            if HP-Typee = 1
            [
             ;print " NE-E is selected "
              set pos 0
              set selected 1
            ]
          ]
          ;---------------------------------------
          ; 1- Checking for __ SE __
          set x-vac orig-x + 2
          set y-vac orig-y - 2
          ; test if this point is vacant
          vacancy-test
          set HP-typee 0
          if isVacant = 1
          [
            ; Check SE-S
            set x-vac orig-x + 4
            set y-vac orig-y - 2
            HP-Test
            if HP-Typee = 1
            [
             ;print " SE-E is selected "
              set pos 1
              set selected 1
            ]
            ; Check NE-E
            set x-vac orig-x + 2
            set y-vac orig-y - 4
            HP-Test
            if HP-Typee = 1
            [
             ;print " SE-S is selected "
              set pos 1
              set selected 1
            ]
          ]
          ;---------------------------------------
          ; 1- Checking for __ Sw __
          set x-vac orig-x - 2
          set y-vac orig-y - 2
          ; test if this point is vacant
          vacancy-test
          set HP-Typee 0
          if isVacant = 1
          [
            ; Check SW-S
            set x-vac orig-x - 2
            set y-vac orig-y - 4
            HP-Test
            if HP-Typee = 1
            [
             ;print " SW-S is selected "
              set pos 2
              set selected 1
            ]
            ; Check NE-E
            set x-vac orig-x - 4
            set y-vac orig-y - 2
            HP-Test
            if HP-Typee = 1
            [
             ;print " SW-W is selected "
              set pos 2
              set selected 1
            ]
          ]
          ;---------------------------------------
          ; 1- Checking for __ NW __
          set x-vac orig-x - 2
          set y-vac orig-y + 2
          ; test if this point is vacant
          vacancy-test
          set HP-Typee 0
          if isVacant = 1
          [
            ; Check SE-S
            set x-vac orig-x - 2
            set y-vac orig-y + 4
            HP-Test
            if HP-Typee = 1
            [
             ;print " NW-N is selected "
              set pos 3
              set selected 1
            ]
            ; Check NE-E
            set x-vac orig-x - 4
            set y-vac orig-y + 2
            HP-Test
            if HP-Typee = 1
            [
             ;print " NE-W is selected "
              set pos 3
              set selected 1
            ]
          ]
          ;////////////////////////////////////////////////////////////////////
          ; Checking neighbors of NE,SE,SW,NW for another H finished
          ;
          ;type "selected= " print selected
          if selected = 0
          [
           ;print " selected is =0 "
            ;---------------------------------------
            ; if in previous section , no H in neighborhood were found
            ; then the amino decides to get cloder to H-Center
            ;---------------------------------------------------------------------
            ; making a list ( possible_H=[1,1,1,1] ) for possible movements for P
            let list-1 []
            let a 1
            set list-1 lput a list-1
            set list-1 lput a list-1
            set list-1 lput a list-1
            set list-1 lput a list-1
            let list-2 []
            set list-2 lput list-1 list-2
            let possible-H matrix:from-row-list list-2

            ; making a list ( dist_p=[0,0,0,0] ) for distance measurement
            set list-1 []
            set a 100
            set list-1 lput a list-1
            set list-1 lput a list-1
            set list-1 lput a list-1
            set list-1 lput a list-1
            set list-2 []
            set list-2 lput list-1 list-2
            let dist-H matrix:from-row-list list-2
            ;--------------------------------------------
            ; get position of selected amino
            set orig-x matrix:get HP-List f-move 1
            set orig-y matrix:get HP-List f-move 2

            ;---------------------------------------
            ; 1- Checking for NE
            set x-vac orig-x + 2
            set y-vac orig-y + 2
            ; test if this point is vacant

            vacancy-test

            ifelse isVacant = 0
            [
              matrix:set possible-H 0 0 0
              ;type "Possible-H= " print possible-H
            ]
            [
             ;print "  H-NE is vacant "
              set stk1 x-vac
              set stk2 y-vac

              ifelse stk1 >= h-center-x
              [
                set stk1 stk1 - h-center-x
              ]
              [
                set stk1 h-center-x - stk1
              ]

              ifelse stk2 >= h-center-y
              [
                set stk2 stk2 - h-center-y
              ]
              [
                set stk2 h-center-y - stk2
              ]
              ; Here we calculate the distance between current Point to H-Center
              set stk1 stk1 * stk1
              set stk2 stk2 * stk2
              set stk3 stk1 + stk2
              set stk3 sqrt stk3

              ; Now we put it in cp-dist list
              matrix:set dist-H 0 0 stk3
              ;type "Dist-H= " print Dist-H
            ]

            ;---------------------------------------
            ; 1- Checking for SE
            set x-vac orig-x + 2
            set y-vac orig-y - 2
            ; test if this point is vacant

            vacancy-test

            ifelse isVacant = 0
            [
              matrix:set possible-H 0 1 0
              ;type "Possible-H= " print possible-H
            ]
            [
              set stk1 x-vac
              set stk2 y-vac
             ;print "  H-SE is vacant "
              ifelse stk1 >= h-center-x
              [
                set stk1 stk1 - h-center-x
              ]
              [
                set stk1 h-center-x - stk1
              ]

              ifelse stk2 >= h-center-y
              [
                set stk2 stk2 - h-center-y
              ]
              [
                set stk2 h-center-y - stk2
              ]
              ; Here we calculate the distance between current Point to H-Center
              set stk1 stk1 * stk1
              set stk2 stk2 * stk2
              set stk3 stk1 + stk2
              set stk3 sqrt stk3

              ; Now we put it in cp-dist list
              matrix:set dist-H 0 1 stk3
              ;type "Dist-H= " print Dist-H
            ]

            ;---------------------------------------
            ; 1- Checking for SW
            set x-vac orig-x - 2
            set y-vac orig-y - 2
            ; test if this point is vacant

            vacancy-test

            ifelse isVacant = 0
            [
              matrix:set possible-H 0 2 0
              ;type "Possible-H= " print possible-H
            ]
            [
             ;print "  H- SW is vacant "
              set stk1 x-vac
              set stk2 y-vac

              ifelse stk1 >= h-center-x
              [
                set stk1 stk1 - h-center-x
              ]
              [
                set stk1 h-center-x - stk1
              ]

              ifelse stk2 >= h-center-y
              [
                set stk2 stk2 - h-center-y
              ]
              [
                set stk2 h-center-y - stk2
              ]
              ; Here we calculate the distance between current Point to H-Center
              set stk1 stk1 * stk1
              set stk2 stk2 * stk2
              set stk3 stk1 + stk2
              set stk3 sqrt stk3

              ; Now we put it in cp-dist list
              matrix:set dist-H 0 2 stk3
              ;type "Dist-H= " print Dist-H
            ]

            ;---------------------------------------
            ; 1- Checking for NW
            set x-vac orig-x - 2
            set y-vac orig-y + 2
            ; test if this point is vacant

            vacancy-test

            ifelse isVacant = 0
            [
              matrix:set possible-H 0 3 0
              ;type "Possible-H= " print possible-H
            ]
            [
             ;print "  H-NW is vacant "
              set stk1 x-vac
              set stk2 y-vac

              ifelse stk1 >= h-center-x
              [
                set stk1 stk1 - h-center-x
              ]
              [
                set stk1 h-center-x - stk1
              ]

              ifelse stk2 >= h-center-y
              [
                set stk2 stk2 - h-center-y
              ]
              [
                set stk2 h-center-y - stk2
              ]
              ; Here we calculate the distance between current Point to H-Center
              set stk1 stk1 * stk1
              set stk2 stk2 * stk2
              set stk3 stk1 + stk2
              set stk3 sqrt stk3

              ; Now we put it in cp-dist list
              matrix:set dist-H 0 3 stk3
              ;type "Dist-H= " print Dist-H
            ]

            set i 0
            set minn 100
            set minn-index 100
            ; serach for maximuum distance to H-Center
            while [i < 4]
            [
              let dist matrix:get dist-H 0 i
              if dist < minn
              [
                set minn dist
                set minn-index i
              ]
              set i i + 1
            ]
            set pos minn-index
          ]
          ;type " H: Min-dist=" type minn type " , min-dist index=" print minn-index
        ]



        if animation
        [
          display wait anime-delay
        ]


        while [ waiting ]
        [
          display wait 1
        ]






        ;=======================================================
        ;=======================================================
        ;=======================================================

        ; $4
        let pos-ok 0 ; pos_ok is 0 unless there is NOT the same location in HP_list (that means No overlap)
        let pos-nok-counter 0 ; counts how many times it has tried to get a valid location

        ; $5
        while [ pos-ok = 0 ]
        [
          ;set pos random 4 ; pos is a randomly selected variable which tells us f_move where should go
                           ; 4- based on (3) , select a possible (0,1,2,3)=(NE,SE,SW,NW) if location not possible goto (3)
                           ;---------
                           ; here we should find out that (F-move,pos) is occupied or not
                           ; so : 1- get the position of f_move
                           ;      2- get the position of pos (+-2,+-2)
                           ;      3- check check HP_list , if the location is oocupied , then the pos-ok will remain 0 , else pos_ok=1 and amino_ok=1
                           ;      4- if pos-nok-counter > 9 then : pos_ok=1 and amino_ok=0
                           ;---------
                           ; so: 1- get the position of f_move

          ;type "selected pos=" type pos Print " doesn't need to be tested "


          set x-amino matrix:get HP-List f-move 1
          set y-amino matrix:get HP-List f-move 2
          ; so: 2- get the position of pos (+-2,+-2)

          ; $6
          if pos = 0
          [
           ;print "  pos= NE "
            set x-amino x-amino + 2
            set y-amino y-amino + 2
          ]
          if pos = 1
          [
           ;print "  pos= SE "
            set x-amino x-amino + 2
            set y-amino y-amino - 2
          ]
          if pos = 2
          [
           ;print "  pos= SW "
            set x-amino x-amino - 2
            set y-amino y-amino - 2
          ]
          if pos = 3
          [
           ;print "  pos = NW "
            set x-amino x-amino - 2
            set y-amino y-amino + 2
          ]

          ; so: 3- check check HP_list , if the location is oocupied
          ; $7
          ;let x-matrix 0
          ;let y-matrix 0
          set dim-list matrix:dimensions HP-List
          set dim-array array:from-list dim-list
          set j array:item dim-array 0
          set i 0
          let answer 1
          while [ i < j ]
          ;       0    13
          [
            set stk1 matrix:get HP-List i 1
            if stk1 = x-amino
            [
              set stk1 matrix:get HP-List i 2
              if stk1 = y-amino
              [
                set answer 0
              ]
            ]
            set i i + 1
          ]

          ; $8
          ifelse answer = 0
          [
            ; $10
            set pos-ok 0
            set pos-nok-counter pos-nok-counter + 1
           ;print " pos is occupied"
            if pos-nok-counter > 9
            [
              set pos-ok 1 ; go out of selecting neighborhood loop
              set amino-ok 0 ;inside selecting a new amino
              set pos-nok-counter 0 ; reset pos-nok-counter
            ]
          ]
          [
            ;$9
            set pos-ok 1
            set amino-ok 1
            set pos-nok-counter 0
           ;print " Pos is NOT occupied"
          ]
        ]
      ]


      if animation
        [
          display wait anime-delay
        ]

      ;----------------------
      ;----------------------  Til here: an AMINO with a valid DIRECTION for moving is selected
      ;----------------------

      ;print "+++ a valid AMINO with valid Direction is selected"

      ; 6- go to place selected in (4)
      ask turtle f-move [ setxy x-amino y-amino ]


      if animation
        [
          display wait anime-delay
        ]

      matrix:set HP-List f-move 1 x-amino
      matrix:set HP-List f-move 2 y-amino

      ;type "*** valid selections: Turtle " type f-move type " goes to " type x-amino type "," type y-amino print " "

      let anchor-1 f-move
      let anchor-2 f-move
      let anchor-counter 0
      let move1 100
      let move2 100

      set dim-list matrix:dimensions HP-List
      set dim-array array:from-list dim-list
      set j array:item dim-array 0

      ; 8- Check all link lengths

      set links-ok 0
      let jj j - 1


      while [ links-ok = 0 ]
      [

        set links-ok 1
        set move1 100
        set move2 100
        set i 0
        let i2 0
        let LL 0



       ;print " Checking and Correcting link length starts here:"
       ;print " ====================="
        ;type "Anchor-1=" type Anchor-1 type " , Move1=" print move1
        ;type "Anchor-2=" type Anchor-2 type " , Move2=" print move2
       ;print " ====================="

        while [ i < jj ]
        [
          set i2 i + 1
          ask link i i2 [ set LL link-length ]
          ifelse ll != 2
          [

            ;type "problem in link" type i type "," type i2 type " - Length= " print ll
            ifelse anchor-counter = 0
            [
              ;--------------------------------
              let special-case 1
              ; What is SPECIAL CASE?
              ; its a situation when there is only one incorrect link in the the sequence (because of assymetry in randomly selected amino for moving
              ; in normal condition without special case) when the algorithm gets to first incorrect link length,
              ; it checks the Anchor-Counter , and regarding that its = 0 , so it only compares anchor1 to the heads of link , and
              ; regarding that no heads are equal to Anchor1 , then it can't select a correct move2 so , based on previous run the numbers for
              ; anchor2 and move2 gets equal and compiler announces an error

              ;type "anchor-counter= "  print anchor-counter
              ;type "Anchor-1=" print anchor-1
              set links-ok 0
              if i = anchor-1
              [
                set move1 i2
                set special-case 0
                ;type "#new Move1= "  print Move1
              ]
              if i2 = anchor-1
              [
                set move1 i
                set special-case 0
                ;type "#new Move1= "  print Move1
              ]
              set anchor-counter anchor-counter + 1

              if special-case = 1
              [
                if i = anchor-2
                [
                  set move2 i2
                  ;type "#Move2= "  print Move2
                ]
                if i2 = anchor-2
                [
                  set move2 i
                  ;type "#Move2= "  print Move2
                ]
                set anchor-counter 0
              ]
            ]
            [
              ;type "anchor-counter= "  print anchor-counter
              ;type "Anchor-2=" print anchor-2
              set links-ok 0
              if i = anchor-2
              [
                set move2 i2
                ;type "#Move2= "  print Move2
              ]
              if i2 = anchor-2
              [
                set move2 i
                ;type "#Move2= "  print Move2
              ]
              set anchor-counter 0
            ]

          ];if LL != 2
          [
            ;type "link: "  type i type "," type i2 print " is OK"
          ];if LL = 2
          set i i + 1
        ] ;while [ i < j ]
        ;type "Move1=" type move1 type " , Move2= " print move2

          ;  9- All links_length=1 ?   -> No:
          ;                                  - find the other head of the link not equal to 1, (using LAST_MOVED_INDEX)
          ;                                  - if the move was NE: go NE , or two step to N, or two step to E
          ;                                                    SE: go SE , or two step to S, or two step to E
          ;                                                    SW: go SW , or two step to S, or two step to W
          ;                                                    NW: go NW , or two step to N, or two step to W
          ;                                  - move there
          ;                                  - goto (8)
        set anchor-counter 0


        if it-counter > 0
        [
          if move1 = 100
          [
            if move2 = 100
            [
              if links-ok = 0
              [
               ;print " ZZZZ Reset"
                set reset 1
                set links-ok 1
              ]
            ]
          ]
        ]



        ifelse links-ok = 0
        [
         ;print " Checking links finished - Links not ok "
         ;print " ====================="
          ;type "Anchor-1=" type Anchor-1 type " , Move1=" print move1
          ;type "Anchor-2=" type Anchor-2 type " , Move2=" print move2
         ;print " ====================="

          set LL 0

          let link1-correction 0
          let link2-correction 0


          ifelse move1 < 100
          [
            ;type "New amino to move (move1) is: "  print move1
            ; #POS0
            if pos = 0
            ; Main directions are :  NE,E,N,SE,S,SW,W,NW
            [
              ;type "previous pos was = "  ;type pos type ", Getting X,Y of Move1 = " print move1

              ; get coordination of MOV1
              set x-amino matrix:get HP-List move1 1
              set y-amino matrix:get HP-List move1 2
              ;type " X-amino , Y-amino of move1 "  type x-amino type " , " print y-amino

              ; [(pos=0) means : NE , two steps to North, two steps to East]
              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              set x-vac x-amino + 2
              set y-vac y-amino + 2
              ;
              ; test if this point is vacant
              vacancy-test
              ;type " pos = 0 + is NE of move1 Vacant ?-> "  print isVacant
              ;
              if isVacant = 1
              [
                ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                ask turtle move1 [setxy x-vac y-vac]
                ;type "NE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                ; then check the link length of anchor-1 and move1
                ask link anchor-1 move1 [ set LL link-length ]
                if ll = 2
                [
                  ;if the link = 2 then link1-correction = 1
                  ask turtle move1 [setxy x-vac y-vac]
                 ;print " Link is =2 , and setting new location in HP-List"
                  matrix:set HP-List move1 1 x-vac
                  matrix:set HP-List move1 2 y-vac
                  set link1-correction 1
                  set anchor-1 move1
                  ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                ]
              ]
              ;-------------------------
              ; IF(link1-correction = 0)
              ;               try: shift MOV1 to (+4,0)
              ;               test if this point is vacant
              ;               then check the link length of anchor-1 and move1
              ;               if the link = 2 then link1-correction = 1
              ;               anchor-1= mov1
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)

                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is E of move1 Vacant ?-> "  print isVacant
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ;type "E is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              ; IF(link1-correction = 0)
              ;               try: shift MOV1 to (0,+4)
              ;               test if this point is vacant
              ;               then check the link length of anchor-1 and move1
              ;               if the link = 2 then link1-correction = 1
              ;               anchor-1= mov1
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is N of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ;type "N is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is SE of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ;type "SE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is S of move1 Vacant ?-> "   PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ;type "S is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is SW of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ;type "SW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is W of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ;type "W is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 0 + is NW of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ;type "NW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------

              ifelse link1-correction = 0
              [
               ;print " __ MOVE1 - POS=0 - No Location for Pos = 0 , Must Reset"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " pos = 0 (move1) link1 ok"
              ]
            ]
            ;**********************************
            ; #POS1
            if pos = 1
            [
              ;type "previous pos was = "  type pos type ", Getting X,Y of Move1 = " print move1
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move1 1
              set y-amino matrix:get HP-List move1 2
              ;type "New X-amino , Y-amino of move1 "  type x-amino type "," print y-amino
              ;----------------------------------------
              ; Now rest of places
              if link1-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is SE of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ;type "SE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;----------------------------------------
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is E of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "E is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is S of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "S is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link1-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is NE of move1 Vacant ?-> " PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "NE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is N of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "N is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is SW of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "SW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is W of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
                  ;type "W is vacant, turtle move1=" ;type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                    ;type "Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
                ;type "pos = 1 + is NW of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
          ;type"NW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              ifelse link1-correction = 0
              [
               ;print " MOVE1- Pos=1 has problem - MUST RESET"
                set reset 1
                ;set pos 5
                ;set move2 100
                set links-ok 1
              ]
              [
               ;print " pos=1 , (move1) link1 ok"
              ]

              ;-------------------------------------
              ;-------------------------------------
              ;---------------------------------------POS1
            ];if pos = 1
             ; #POS2
            if pos = 2
            [
           ;type"previous pos was = "  type pos type ", Getting X,Y of Move1 = " print move1
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move1 1
              set y-amino matrix:get HP-List move1 2
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is SW of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"SW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is S of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"S is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is W of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"W is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link1-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is SE of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"SE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;----------------------------------------
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is E of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"E is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is N of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"N is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]


              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is NW of move1 Vacant ?-> "  PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"NWE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link1-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is NE of move1 Vacant ?-> "  PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"NE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              ifelse link1-correction = 0
              [
               ;print " MOVE1- POS=2 HASP PROBLEM MUST RESET"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " pos = 2 , (move1) link1 ok"
              ]

              ;-------------------------------------
              ;-------------------------------------
              ;---------------------------------------POS2
            ];if pos = 2
            if pos = 3
            [
           ;type"previous pos was = "  type pos type ", Getting X,Y of Move1 = " print move1
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move1 1
              set y-amino matrix:get HP-List move1 2
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is SW of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"SW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is S of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"S is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is W of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"W is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link1-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is SE of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"SE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              ;----------------------------------------
              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is E of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"E is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              if link1-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is N of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"N is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]


              ;-----------------------------------------
              if link1-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is NW of move1 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"NW is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]

              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link1-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is NE of move1 Vacant ?-> " PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move1" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move1 [setxy x-vac y-vac]
                  ; then check the link length of anchor-1 and move1
                  ask link anchor-1 move1 [ set LL link-length ]
               ;type"NE is vacant, turtle move1=" type move1 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link1-correction = 1
                    ask turtle move1 [setxy x-vac y-vac]
                    matrix:set HP-List move1 1 x-vac
                    matrix:set HP-List move1 2 y-vac
                    set link1-correction 1
                    set anchor-1 move1
                 ;type"Link is = 2 ,setting in HP-List , Move1 = " type move1 type " - anchor1=" print anchor-1
                  ]
                ]
              ]
              ;-----------------------------------------
              ifELSE link1-correction = 0
              [
               ;print " MOVE1- Pos=3 has problem - MUST RESET"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " pos = 3, (move1) link ok"
              ]
              ;-------------------------------------
              ;-------------------------------------
              ;---------------------------------------POS2
            ]; if pos = 3
             ; tavajoh!! ( anchor2= mov2 ) ro bayad be jomle haie bala ezafe kard
          ]; if move1 < 100
          [
           ;print " Right side (move1) doesn't need to move (Links are ok)"
          ]

          if animation
        [
          display wait anime-delay
        ]

          while [ waiting ]
          [
            ;print  "aposdaposdapodiapodiasodiapdipaosdiapodiapodiapsodidsoiaspdiasodi"
            display wait 1
          ]
           ;===========================================================
           ;===========================================================
           ;==================   Now for Move2  =======================
           ;===========================================================
           ;===========================================================
;          if anchor-2 = move2
;          [
;            set move2 100
;          ]

          ;print "  -> END OF CORRECTING LINK 1 SECTION"

          ifelse move2 < 100
          [
         ;type"New amino to move (move2) is: "  print move2
            ; #POS0
            if pos = 0
            ; Main directions are :  NE,E,N,SE,S,SW,W,NW
            [
           ;type"previous pos was = "  type pos type ", Getting X,Y of Move2 = " print move2
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move2 1
              set y-amino matrix:get HP-List move2 2
              ; [(pos=0) means : NE , two steps to North, two steps to East]
              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              set x-vac x-amino + 2
              set y-vac y-amino + 2
              ;
              ; test if this point is vacant
              vacancy-test
           ;type"pos = 0 + is NE of move2 Vacant ?-> " PRINT ISVACANT
              ;
              if isVacant = 1
              [
                ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                ask turtle move2 [setxy x-vac y-vac]
                ; then check the link length of anchor-2 and move2
                ask link anchor-2 move2 [ set LL link-length ]
             ;type"NE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                if ll = 2
                [
                  ;if the link = 2 then link2-correction = 1
                  ask turtle move2 [setxy x-vac y-vac]
                  matrix:set HP-List move2 1 x-vac
                  matrix:set HP-List move2 2 y-vac
                  set link2-correction 1
                  set anchor-2 move2
               ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                ]
              ]
              ;-------------------------
              ; IF(link2-correction = 0)
              ;               try: shift MOV1 to (+4,0)
              ;               test if this point is vacant
              ;               then check the link length of anchor-2 and move2
              ;               if the link = 2 then link2-correction = 1
              ;               anchor-2= mov1
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is E of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"E is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              ; IF(link2-correction = 0)
              ;               try: shift MOV1 to (0,+4)
              ;               test if this point is vacant
              ;               then check the link length of anchor-2 and move2
              ;               if the link = 2 then link2-correction = 1
              ;               anchor-2= mov1
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is N of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"N is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is SW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is S of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"S is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is SW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is W of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"W is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 0 + is NW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is = 2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------

              ifelse link2-correction = 0
              [
               ;print " POS=0 for Move2 has problem - Must RESET"
                set reset 1
                set links-ok 1
                ;set pos 5
                ;set move2 100
              ]
              [
               ;print " move2 , pos=0 , link ok"
              ]
            ]
            ;**********************************
            ; #POS1
            if pos = 1
            [
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move2 1
              set y-amino matrix:get HP-List move2 2
              ;----------------------------------------
              ; Now rest of places
              if link2-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is SE of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is E of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"E is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is S of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"S is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link2-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is NE of move2 Vacant ?-> " PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is N of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"N is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is SW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is W of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"W is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 1 + is NW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              ifELSE link2-correction = 0
              [
               ;print " pos=1 for Move2 has problem - MUST RESET"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " move2 , pos=1 , link ok"
              ]

              ;-------------------------------------
              ;-------------------------------------
              ;---------------------------------------POS1
            ];if pos = 1
             ; #POS2
            if pos = 2
            [
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move2 1
              set y-amino matrix:get HP-List move2 2
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is SW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is s of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"S is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is W of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"W is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link2-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is SE of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is E of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"E is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is N of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"N is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]


              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is NW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link2-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
             ;type"pos = 2 + is NE of move2 Vacant ?-> " PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              ifelse link2-correction = 0
              [
               ;print " POS=2 for move2 has problem - MUST RESET"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " move2, pos=2 , link ok"
              ]

              ;-------------------------------------
              ;-------------------------------------
              ;---------------------------------------POS2
            ];if pos = 2
            if pos = 3
            [
              ;---------------------------------------
              ; get coordination of MOV1
              set x-amino matrix:get HP-List move2 1
              set y-amino matrix:get HP-List move2 2
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> SW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is SW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> S
                ;------
                set x-vac x-amino + 0
                set y-vac y-amino - 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is S of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"S is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> W
                ;------
                set x-vac x-amino - 4
                set y-vac y-amino - 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is W of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"W is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              ; Now rest of places
              if link2-correction = 0
              [
                ; [(pos=0) means : NE , two steps to North, two steps to East]
                ;--------------------------------------
                ; -> SE
                ;------
                set x-vac x-amino + 2
                set y-vac y-amino - 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is SE of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"SE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;----------------------------------------
              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> E
                ;------
                ; so first try: shift MOV1 to (+2,-2)
                set x-vac x-amino + 4
                set y-vac y-amino + 0
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is E of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"E is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              if link2-correction = 0
              [
                ;--------------------------------------
                ; -> N
                ;------
                ; so first try: shift MOV1 to (0,+4)
                set x-vac x-amino + 0
                set y-vac y-amino + 4
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is N of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"N is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]


              ;-----------------------------------------
              if link2-correction = 0
              [
                ;------
                ; -> NW
                ;------
                set x-vac x-amino - 2
                set y-vac y-amino + 2
                ; Test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is NW of move2 Vacant ?-> " PRINT ISVACANT
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NW is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]

              ;--------------------------------------
              ; -> NE
              ;------
              ; so first try: shift MOV1 to (+2,+2)
              if link2-correction = 0
              [
                set x-vac x-amino + 2
                set y-vac y-amino + 2
                ;
                ; test if this point is vacant
                vacancy-test
             ;type"pos = 3 + is NE of move2 Vacant ?-> " PRINT ISVACANT
                ;
                if isVacant = 1
                [
                  ; move "move2" to candidate point=(x-vac,y-vac) to measure link length
                  ask turtle move2 [setxy x-vac y-vac]
                  ; then check the link length of anchor-2 and move2
                  ask link anchor-2 move2 [ set LL link-length ]
               ;type"NE is vacant, turtle move2=" type move2 type " ,Goes to:(" type x-vac type "," type y-vac print ")"
                  if ll = 2
                  [
                    ;if the link = 2 then link2-correction = 1
                    ask turtle move2 [setxy x-vac y-vac]
                    matrix:set HP-List move2 1 x-vac
                    matrix:set HP-List move2 2 y-vac
                    set link2-correction 1
                    set anchor-2 move2
                 ;type"Link is =2 ,setting in HP-List , Move2 = " type move2 type " - anchor2=" print anchor-2
                  ]
                ]
              ]
              ;-----------------------------------------
              ifelse link2-correction = 0
              [
               ;print " MOVE1- Pos=3 has problem - MUST RESET"
                set reset 1
                set links-ok 1
              ]
              [
               ;print " move2 , pos=3 , link ok"
              ]
              ;---------------------------------------POS2
            ] ; if pos = 3
              ; tavajoh!! ( anchor2= mov2 ) ro bayad be jomle haie bala ezafe kard
          ]; if move2 < 100
          [
           ;print " Left side (move2) doesn't need to move (Links are ok)"
          ] ; else if move2 >= 100

         ;print "  -> END OF CORRECTING LINK 2 SECTION"

          if animation
        [
          display wait anime-delay
        ]

          while [ waiting ]
          [
            ;print  "aposdaposdapodiapodiasodiapdipaosdiapodiapodiapsodidsoiaspdiasodi"
            display wait 1
          ]
        ]; if links-ok = 0
        [

          ;print "  all likns were checked and are OK , going to out of while-loop"
          ;set reset 0
          ;print "All Links are ok"
          ;set links-ok 1
        ]

      ]; while [ links-ok = 0 ]
       ;================================
       ;================================
       ;================================

     ;print " here is out of Link-length While-Loop... Reset =0/1 section"

      if animation
        [
          display wait anime-delay
        ]

      while [ waiting ]
      [
        ;print  "aposdaposdapodiapodiasodiapdipaosdiapodiapodiapsodidsoiaspdiasodi"
        display wait 1
      ]


      ifelse reset = 1
      [
        set reset 0
       ;print " ____ In Reset section ________"
        ; 1- copy HP-List-Reference to HP-List
       ;print " HP-list: "
        ;print matrix:pretty-print-text HP-List

       ;print " HP-list-Reference: "
        ;print matrix:pretty-print-text HP-List-reference

        ; Copying "HP-list-Reference" to "HP-List"
        ;set HP-list HP-List-reference

        set hp1 []
        set hp2 []
        set dim-list matrix:dimensions HP-List-reference
        set dim-array array:from-list dim-list
        set j array:item dim-array 0
        set i 0
        while [ i < j ]
        [
          set stk1 matrix:get HP-List-reference i 0
          set hp1 lput stk1 hp1
          set stk1 matrix:get HP-List-reference i 1
          set hp1 lput stk1 hp1
          set stk1 matrix:get HP-List-reference i 2
          set hp1 lput stk1 hp1
          ; [ x,y,z ]
          set hp2 lput hp1 hp2
          set hp1 []
          set i i + 1
        ]
        set HP-List matrix:from-row-list hp2



        ; 2- Set the locations of HP-List to the
        set dim-list matrix:dimensions HP-List
        set dim-array array:from-list dim-list
        set j array:item dim-array 0
        set i 0
        set isVacant 1
        while [ i < j ]
        ;       0    13
          [

            if animation
            [
              display wait anime-delay
            ]

            Let xxx matrix:get HP-List i 1
            Let yyy matrix:get HP-List i 2
            ask turtle i [setxy xxx yyy ]
            set i i + 1
          ]
      ]
      ;======== if reset is not 1 (= do not need to reset)
      [
       ;print " _____In NOT Resetsection, Check energy, set config_____"
        ; 10- calculate Energy_New
        set energy-new 0
        let counter 0
        let xx 0
        let yy 0
        while [ counter < seq-len ]
        [
          set stk1 matrix:get HP-List counter 0
          ;print "Counter="
          ;print counter
          if stk1 = 1
          [
            set x-gen matrix:get HP-List counter 1
            set y-gen matrix:get HP-List counter 2
            ; Checking North
            set xx x-gen
            set yy y-gen + 2
            set i counter + 2
            while [i < j]
            [
              set stk1 matrix:get HP-List i 0
              if stk1 = 1
              [
                set stk1 matrix:get HP-List i 1
                if stk1 = xx
                [
                  set stk1 matrix:get HP-List i 2
                  if stk1 = yy
                  [
                    set energy-new energy-new + 1
                  ]
                ]
              ]
              set i i + 1
            ]
            ;================================
            ; Checking East
            set xx x-gen + 2
            set yy y-gen
            set i counter + 2
            while [i < j]
            [
              set stk1 matrix:get HP-List i 0
              if stk1 = 1
              [
                set stk1 matrix:get HP-List i 1
                if stk1 = xx
                [
                  set stk1 matrix:get HP-List i 2
                  if stk1 = yy
                  [
                    set energy-new energy-new + 1
                  ]
                ]
              ]
              set i i + 1
            ]
            ;================================
            ; Checking South
            set xx x-gen
            set yy y-gen - 2
            set i counter + 2
            while [i < j]
            [
              set stk1 matrix:get HP-List i 0
              if stk1 = 1
              [
                set stk1 matrix:get HP-List i 1
                if stk1 = xx
                [
                  set stk1 matrix:get HP-List i 2
                  if stk1 = yy
                  [
                    set energy-new energy-new + 1
                  ]
                ]
              ]
              set i i + 1
            ]

            ;================================
            ; Checking West
            set xx x-gen - 2
            set yy y-gen
            set i counter + 2
            while [i < j]
            [
              set stk1 matrix:get HP-List i 0
              if stk1 = 1
              [
                set stk1 matrix:get HP-List i 1
                if stk1 = xx
                [
                  set stk1 matrix:get HP-List i 2
                  if stk1 = yy
                  [
                    set energy-new energy-new + 1
                  ]
                ]
              ]
              set i i + 1
            ]
          ]
          set counter counter + 1
        ]
        set energy-new energy-new * -1
        ;set energy energy-new

     ;type"Energy-new=" type energy-new type " - Energy-old=" print energy-old
        ifelse energy-new > energy-old
        [
         ;print " new energy is worse than old one"
          let delta energy-old - energy-new
          ;set delta delta * +1
          ;
          let z delta / Temp

       ;type"Z=" print z

          let prob 2.7183 ^ z
          let rand random-float 1
          ;

          ; Regarding the fact that Prob decreases as T decreses, so
          ; When Prob(which is related to T) is bigger than Rand the move is accepted
          ifelse prob > rand
          [
             set temp-tek temp-tek + 1
             if temp-tek = 2
             [
               set Temp Temp * decrease-rate
               set current-temp Temp
               set current-temp precision current-temp 3
               set temp-tek 0
             ]
             ;type"Prob= " type prob type " > " type "Rand= " type Rand print " move is accepted"
             update-plots

          ]
          [
            ; ----------------------------------------
            ;  If the move is not accepted and the last ok
            ;   structure should be replaced
            ; ----------------------------------------
            ; 1- copy HP-List-Reference to HP-List
            ;type "Prob= " type prob type " > " type "Rand= " type Rand print " move is NOT accepted"


            ;set HP-list HP-List-reference
            set hp1 []
            Set hp2 []
            Set dim-list matrix:dimensions HP-List-reference
            set dim-array array:from-list dim-list
            set j array:item dim-array 0
            set i 0
            while [ i < j ]
            [
              set stk1 matrix:get HP-List-reference i 0
              set hp1 lput stk1 hp1
              set stk1 matrix:get HP-List-reference i 1
              set hp1 lput stk1 hp1
              set stk1 matrix:get HP-List-reference i 2
              set hp1 lput stk1 hp1
              ; [ x,y,z ]
              set hp2 lput hp1 hp2
              set hp1 []
              set i i + 1
            ]
            set HP-List matrix:from-row-list hp2



            ; 2- Set the locations of HP-List to the
            set dim-list matrix:dimensions HP-List
            set dim-array array:from-list dim-list
            set j array:item dim-array 0
            set i 0
            set isVacant 1
            while [ i < j ]
            [
              Let xxx matrix:get HP-List i 1
              Let yyy matrix:get HP-List i 2
              ask turtle i [setxy xxx yyy ]
              set i i + 1
            ]
          ]; prob < rand
        ]
        [
         ;print "  this energy is better than previous one- so it will be the reference"
          ; if Energy is better than previous state, then take it as reference Matrix


          ;set HP-List-Reference  Hp-List
          ; Copying from HP-List to HP-List-Reference
          set hp1 []
          Set hp2 []
          Set dim-list matrix:dimensions HP-List
          set dim-array array:from-list dim-list
          set j array:item dim-array 0
          set i 0
          while [ i < j ]
          [
            set stk1 matrix:get HP-List i 0
            set hp1 lput stk1 hp1
            set stk1 matrix:get HP-List i 1
            set hp1 lput stk1 hp1
            set stk1 matrix:get HP-List i 2
            set hp1 lput stk1 hp1
            ; [ x,y,z ]
            set hp2 lput hp1 hp2
            set hp1 []
            set i i + 1
          ]
          set HP-List-reference matrix:from-row-list hp2

          set energy-old energy-new
        ]




      ]
      ;========
    ]


    ; Display best acquired conformation on Screen
    set dim-list matrix:dimensions HP-List-reference
    set dim-array array:from-list dim-list
    set j array:item dim-array 0
    set i 0
    set isVacant 1
    while [ i < j ]
    [
      Let xxx matrix:get HP-List-reference i 1
      Let yyy matrix:get HP-List-reference i 2
      ask turtle i [setxy xxx yyy ]
      set i i + 1
    ]

    ; Calculate related energy
    let xx 0
    let yy 0
    let counter 0
    set energy-new 0
    while [ counter < seq-len ]
    [
      let stk1 matrix:get HP-List-reference counter 0
      ;print "Counter="
      ;print counter
      if stk1 = 1
      [
        set x-gen matrix:get HP-List-reference counter 1
        set y-gen matrix:get HP-List-reference counter 2
        ; Checking North
        set xx x-gen
        set yy y-gen + 2
        set i counter + 2
        while [i < j]
        [
          set stk1 matrix:get HP-List-reference i 0
          if stk1 = 1
          [
            set stk1 matrix:get HP-List-reference i 1
            if stk1 = xx
            [
              set stk1 matrix:get HP-List-reference i 2
              if stk1 = yy
              [
                set energy-new energy-new + 1
              ]
            ]
          ]
          set i i + 1
        ]
        ;================================
        ; Checking East
        set xx x-gen + 2
        set yy y-gen
        set i counter + 2
        while [i < j]
        [
          set stk1 matrix:get HP-List-reference i 0
          if stk1 = 1
          [
            set stk1 matrix:get HP-List-reference i 1
            if stk1 = xx
            [
              set stk1 matrix:get HP-List-reference i 2
              if stk1 = yy
              [
                set energy-new energy-new + 1
              ]
            ]
          ]
          set i i + 1
        ]
        ;================================
        ; Checking South
        set xx x-gen
        set yy y-gen - 2
        set i counter + 2
        while [i < j]
        [
          set stk1 matrix:get HP-List-reference i 0
          if stk1 = 1
          [
            set stk1 matrix:get HP-List-reference i 1
            if stk1 = xx
            [
              set stk1 matrix:get HP-List-reference i 2
              if stk1 = yy
              [
                set energy-new energy-new + 1
              ]
            ]
          ]
          set i i + 1
        ]

        ;================================
        ; Checking West
        set xx x-gen -  2
        set yy y-gen
        set i counter + 2
        while [i < j]
        [
          set stk1 matrix:get HP-List-reference i 0
          if stk1 = 1
          [
            set stk1 matrix:get HP-List-reference i 1
            if stk1 = xx
            [
              set stk1 matrix:get HP-List-reference i 2
              if stk1 = yy
              [
                set energy-new energy-new + 1
              ]
            ]
          ]
          set i i + 1
        ]
      ]
      set counter counter + 1
    ]
    set energy-new energy-new * -1

    set eeenergy energy-new
    set Mas-time timer
    type "Mast-Time=" type mas-time type "  , Energy="  print energy-new
    update-plots
  tick
  ;print matrix:pretty-print-text HP-List
end

to vacancy-test
  let dim-list matrix:dimensions HP-List
  let dim-array array:from-list dim-list
  let j array:item dim-array 0
  let i 0
  set isVacant 1
  while [ i < j ]
  ;       0    13
  [
    let stk1 matrix:get HP-List i 1
    if stk1 = x-vac
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-vac
      [
        set isVacant 0
      ]
    ]
    set i i + 1
  ]
end

to HP-test
  let dim-list matrix:dimensions HP-List
  let dim-array array:from-list dim-list
  let j array:item dim-array 0
  let i 0
  set isVacant 1
  while [ i < j ]
  ;       0    13
  [
    let stk1 matrix:get HP-List i 1
    if stk1 = x-vac
    [
      set stk1 matrix:get HP-List i 2
      if stk1 = y-vac
      [
        set HP-Typee matrix:get HP-List i 0
      ]
    ]
    set i i + 1
  ]
end

to patch-color
  ifelse col-col = 0
  [
    set col-col 1
    ask patches [set pcolor white]
  ]
  [
    set col-col 0
    ask patches [set pcolor black]
  ]

end
